---
title: Создание прогрессивных веб-приложений с помощью ASP.NET Core Blazor WebAssembly
author: guardrex
description: Сведения о создании на основе Blazor прогрессивных веб-приложений, то есть приложений, которые используют функции современного браузера и реализуют поведение, свойственное классическим приложениям.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 01/11/2021
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: fcf06295deb41f304b92caa82535a1197c909898
ms.sourcegitcommit: 75db2f684a9302b0be7925eab586aa091c6bd19f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/01/2021
ms.locfileid: "99238239"
---
# <a name="build-progressive-web-applications-with-aspnet-core-blazor-webassembly"></a><span data-ttu-id="a2681-103">Создание прогрессивных веб-приложений с помощью ASP.NET Core Blazor WebAssembly</span><span class="sxs-lookup"><span data-stu-id="a2681-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="a2681-104">Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)</span><span class="sxs-lookup"><span data-stu-id="a2681-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

<span data-ttu-id="a2681-105">Прогрессивное веб-приложение — это обычно одностраничное приложение (SPA), которое использует API и функциональные возможности современного браузера, реализуя свойственное классическим приложениям поведение.</span><span class="sxs-lookup"><span data-stu-id="a2681-105">A Progressive Web Application (PWA) is usually a Single Page Application (SPA) that uses modern browser APIs and capabilities to behave like a desktop app.</span></span> <span data-ttu-id="a2681-106">Blazor WebAssembly — это стандартизированная клиентская платформа веб-приложений с поддержкой API любых браузеров, в том числе API-интерфейсы прогрессивных веб-приложений (PWA), требуемых для реализации следующих возможностей:</span><span class="sxs-lookup"><span data-stu-id="a2681-106">Blazor WebAssembly is a standards-based client-side web app platform, so it can use any browser API, including PWA APIs required for the following capabilities:</span></span>

* <span data-ttu-id="a2681-107">работа в автономном режиме и мгновенная загрузка вне зависимости от скорости сети;</span><span class="sxs-lookup"><span data-stu-id="a2681-107">Working offline and loading instantly, independent of network speed.</span></span>
* <span data-ttu-id="a2681-108">возможность запуска в отдельном окне приложения, а не только в окне браузера;</span><span class="sxs-lookup"><span data-stu-id="a2681-108">Running in its own app window, not just a browser window.</span></span>
* <span data-ttu-id="a2681-109">запуск из меню "Пуск", меню закрепления или с начального экрана основной операционной системы (ОС);</span><span class="sxs-lookup"><span data-stu-id="a2681-109">Being launched from the host's operating system start menu, dock, or home screen.</span></span>
* <span data-ttu-id="a2681-110">получение push-уведомлений от внутреннего сервера, даже если пользователь не работает с приложением;</span><span class="sxs-lookup"><span data-stu-id="a2681-110">Receiving push notifications from a backend server, even while the user isn't using the app.</span></span>
* <span data-ttu-id="a2681-111">автоматическое обновление в фоновом режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-111">Automatically updating in the background.</span></span>

<span data-ttu-id="a2681-112">Слово *прогрессивное* используется для описания таких приложений по следующим причинам:</span><span class="sxs-lookup"><span data-stu-id="a2681-112">The word *progressive* is used to describe such apps because:</span></span>

* <span data-ttu-id="a2681-113">на начальном этапе пользователь может открывать и использовать приложение в своем веб-браузере аналогично любому другому одностраничному приложению;</span><span class="sxs-lookup"><span data-stu-id="a2681-113">A user might first discover and use the app within their web browser like any other SPA.</span></span>
* <span data-ttu-id="a2681-114">затем его можно установить в своей ОС и включить push-уведомления.</span><span class="sxs-lookup"><span data-stu-id="a2681-114">Later, the user progresses to installing it in their OS and enabling push notifications.</span></span>

## <a name="create-a-project-from-the-pwa-template"></a><span data-ttu-id="a2681-115">Создание проекта на основе шаблона PWA</span><span class="sxs-lookup"><span data-stu-id="a2681-115">Create a project from the PWA template</span></span>

# <a name="visual-studio"></a>[<span data-ttu-id="a2681-116">Visual Studio</span><span class="sxs-lookup"><span data-stu-id="a2681-116">Visual Studio</span></span>](#tab/visual-studio)

<span data-ttu-id="a2681-117">При создании **приложения Blazor WebAssembly** в диалоговом окне **Создание нового проекта** установите флажок **Прогрессивное веб-приложение**.</span><span class="sxs-lookup"><span data-stu-id="a2681-117">When creating a new **Blazor WebAssembly App** in the **Create a New Project** dialog, select the **Progressive Web Application** check box:</span></span>

![Установленный флажок "Прогрессивное веб-приложение" в диалоговом окне создания проекта Visual Studio.](progressive-web-app/_static/image1.png)

<!--

# [Visual Studio for Mac](#tab/visual-studio-mac)

-->

# <a name="visual-studio-code--net-core-cli"></a>[<span data-ttu-id="a2681-119">Visual Studio Code или .NET Core CLI</span><span class="sxs-lookup"><span data-stu-id="a2681-119">Visual Studio Code / .NET Core CLI</span></span>](#tab/visual-studio-code+netcore-cli)

<span data-ttu-id="a2681-120">Выполните следующую команду, чтобы создать проект PWA в командной оболочке с параметром `--pwa`:</span><span class="sxs-lookup"><span data-stu-id="a2681-120">Use the following command to create a PWA project in a command shell with the `--pwa` switch:</span></span>

```dotnetcli
dotnet new blazorwasm -o MyBlazorPwa --pwa
```

<span data-ttu-id="a2681-121">В предыдущей команде параметр `-o|--output` создает новую папку для приложения с именем `MyBlazorPwa`.</span><span class="sxs-lookup"><span data-stu-id="a2681-121">In the preceding command, the `-o|--output` option creates a new folder for the app named `MyBlazorPwa`.</span></span>

---

<span data-ttu-id="a2681-122">При необходимости PWA можно настроить для приложения, созданного на основе размещенного шаблона ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="a2681-122">Optionally, PWA can be configured for an app created from the ASP.NET Core Hosted template.</span></span> <span data-ttu-id="a2681-123">Сценарий прогрессивного веб-приложения не зависит от модели размещения.</span><span class="sxs-lookup"><span data-stu-id="a2681-123">The PWA scenario is independent of the hosting model.</span></span>

## <a name="convert-an-existing-blazor-webassembly-app-into-a-pwa"></a><span data-ttu-id="a2681-124">Преобразование существующего приложения Blazor WebAssembly в PWA</span><span class="sxs-lookup"><span data-stu-id="a2681-124">Convert an existing Blazor WebAssembly app into a PWA</span></span>

<span data-ttu-id="a2681-125">В этом разделе приводятся указания по преобразованию существующего приложения Blazor WebAssembly в PWA.</span><span class="sxs-lookup"><span data-stu-id="a2681-125">Convert an existing Blazor WebAssembly app into a PWA following the guidance in this section.</span></span>

<span data-ttu-id="a2681-126">В файле проекта приложения:</span><span class="sxs-lookup"><span data-stu-id="a2681-126">In the app's project file:</span></span>

* <span data-ttu-id="a2681-127">Добавьте указанное ниже свойство `ServiceWorkerAssetsManifest` в `PropertyGroup`:</span><span class="sxs-lookup"><span data-stu-id="a2681-127">Add the following `ServiceWorkerAssetsManifest` property to a `PropertyGroup`:</span></span>

  ```xml
    ...
    <ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
  </PropertyGroup>
   ```

* <span data-ttu-id="a2681-128">Добавьте указанный ниже элемент `ServiceWorker` в `ItemGroup`:</span><span class="sxs-lookup"><span data-stu-id="a2681-128">Add the following `ServiceWorker` item to an `ItemGroup`:</span></span>

  ```xml
  <ItemGroup>
    <ServiceWorker Include="wwwroot\service-worker.js" 
      PublishedContent="wwwroot\service-worker.published.js" />
  </ItemGroup>
  ```

<span data-ttu-id="a2681-129">Для получения статических ресурсов воспользуйтесь **одним** из следующих подходов:</span><span class="sxs-lookup"><span data-stu-id="a2681-129">To obtain static assets, use **one** of the following approaches:</span></span>

::: moniker range=">= aspnetcore-5.0"

* <span data-ttu-id="a2681-130">Создайте отдельный новый проект PWA с помощью команды [`dotnet new`](/dotnet/core/tools/dotnet-new) в командной оболочке:</span><span class="sxs-lookup"><span data-stu-id="a2681-130">Create a separate, new PWA project with the [`dotnet new`](/dotnet/core/tools/dotnet-new) command in a command shell:</span></span>

  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa
  ```
  
  <span data-ttu-id="a2681-131">В предыдущей команде параметр `-o|--output` создает новую папку для приложения с именем `MyBlazorPwa`.</span><span class="sxs-lookup"><span data-stu-id="a2681-131">In the preceding command, the `-o|--output` option creates a new folder for the app named `MyBlazorPwa`.</span></span>
  
  <span data-ttu-id="a2681-132">Если вы не преобразуете приложение для использования в последнем выпуске, передайте параметр `-f|--framework`.</span><span class="sxs-lookup"><span data-stu-id="a2681-132">If you aren't converting an app for the latest release, pass the `-f|--framework` option.</span></span> <span data-ttu-id="a2681-133">В следующем примере создается приложение для ASP.NET Core версии 3.1:</span><span class="sxs-lookup"><span data-stu-id="a2681-133">The following example creates the app for ASP.NET Core version 3.1:</span></span>
  
  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa -f netcoreapp3.1
  ```

* <span data-ttu-id="a2681-134">Перейдите по следующему URL-адресу в репозиторий GitHub для ASP.NET Core, который содержит ссылки на справочные материалы и ресурсы по выпуску 5.0.</span><span class="sxs-lookup"><span data-stu-id="a2681-134">Navigate to the ASP.NET Core GitHub repository at the following URL, which links to 5.0 release reference source and assets.</span></span> <span data-ttu-id="a2681-135">Если вы не преобразуете приложение для выпуска 5.0, выберите выпуск, с которым вы работаете, в раскрывающемся списке **Переключение ветвей или тегов** для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-135">If you aren't converting an app for the 5.0 release, select the release that you're working with from the **Switch branches or tags** drop-down list that applies to your app.</span></span>

  [<span data-ttu-id="a2681-136">dotnet/aspnetcore (выпуск 5.0), шаблон проекта Blazor WebAssembly, папка `wwwroot`</span><span class="sxs-lookup"><span data-stu-id="a2681-136">dotnet/aspnetcore (release 5.0) Blazor WebAssembly project template `wwwroot` folder</span></span>](https://github.com/dotnet/aspnetcore/tree/release/5.0/src/ProjectTemplates/Web.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

::: moniker-end

::: moniker range="< aspnetcore-5.0"

* <span data-ttu-id="a2681-137">Создайте отдельный новый проект PWA с помощью команды [`dotnet new`](/dotnet/core/tools/dotnet-new) в командной оболочке.</span><span class="sxs-lookup"><span data-stu-id="a2681-137">Create a separate, new PWA project with the [`dotnet new`](/dotnet/core/tools/dotnet-new) command in a command shell.</span></span> <span data-ttu-id="a2681-138">Передайте параметр `-f|--framework`, чтобы выбрать версию.</span><span class="sxs-lookup"><span data-stu-id="a2681-138">Pass the `-f|--framework` option to select the version.</span></span> <span data-ttu-id="a2681-139">В следующем примере создается приложение для ASP.NET Core версии 3.1:</span><span class="sxs-lookup"><span data-stu-id="a2681-139">The following example creates the app for ASP.NET Core version 3.1:</span></span>
  
  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa -f netcoreapp3.1
  ```
  
  <span data-ttu-id="a2681-140">В предыдущей команде параметр `-o|--output` создает новую папку для приложения с именем `MyBlazorPwa`.</span><span class="sxs-lookup"><span data-stu-id="a2681-140">In the preceding command, the `-o|--output` option creates a new folder for the app named `MyBlazorPwa`.</span></span>

* <span data-ttu-id="a2681-141">Перейдите по следующему URL-адресу в репозиторий GitHub для ASP.NET Core, который содержит ссылки на справочные материалы и ресурсы по выпуску 3.1:</span><span class="sxs-lookup"><span data-stu-id="a2681-141">Navigate to the ASP.NET Core GitHub repository at the following URL, which links to 3.1 release reference source and assets:</span></span>

  [<span data-ttu-id="a2681-142">dotnet/aspnetcore (выпуск 3.1), шаблон проекта Blazor WebAssembly, папка `wwwroot`</span><span class="sxs-lookup"><span data-stu-id="a2681-142">dotnet/aspnetcore (release 3.1) Blazor WebAssembly project template `wwwroot` folder</span></span>](https://github.com/dotnet/aspnetcore/tree/release/3.1/src/ProjectTemplates/ComponentsWebAssembly.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

  > [!NOTE]
  > <span data-ttu-id="a2681-143">URL-адрес шаблона проекта Blazor WebAssembly изменился после выпуска ASP.NET Core 3.1.</span><span class="sxs-lookup"><span data-stu-id="a2681-143">The URL for Blazor WebAssembly project template changed after the release of ASP.NET Core 3.1.</span></span> <span data-ttu-id="a2681-144">Справочные ресурсы для выпуска 5.0 и более поздних доступны по следующему URL-адресу:</span><span class="sxs-lookup"><span data-stu-id="a2681-144">Reference assets for 5.0 or later are available at the following URL:</span></span>
  >
  > [<span data-ttu-id="a2681-145">dotnet/aspnetcore (выпуск 5.0), шаблон проекта Blazor WebAssembly, папка `wwwroot`</span><span class="sxs-lookup"><span data-stu-id="a2681-145">dotnet/aspnetcore (release 5.0) Blazor WebAssembly project template `wwwroot` folder</span></span>](https://github.com/dotnet/aspnetcore/tree/release/5.0/src/ProjectTemplates/Web.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

::: moniker-end

<span data-ttu-id="a2681-146">Скопируйте следующие файлы из папки `wwwroot` источника в созданном вами приложении или из справочных ресурсов в репозитории GitHub `dotnet/aspnetcore` в папку `wwwroot` приложения:</span><span class="sxs-lookup"><span data-stu-id="a2681-146">From the source `wwwroot` folder either in the app that you created or from the reference assets in the `dotnet/aspnetcore` GitHub repository, copy the following files into the app's `wwwroot` folder:</span></span>

* `icon-512.png`
* `manifest.json`
* `service-worker.js`
* `service-worker.published.js`

<span data-ttu-id="a2681-147">В файле `wwwroot/index.html` приложения:</span><span class="sxs-lookup"><span data-stu-id="a2681-147">In the app's `wwwroot/index.html` file:</span></span>

* <span data-ttu-id="a2681-148">Добавьте элементы `<link>` для манифеста и значка приложения:</span><span class="sxs-lookup"><span data-stu-id="a2681-148">Add `<link>` elements for the manifest and app icon:</span></span>

  ```html
  <link href="manifest.json" rel="manifest" />
  <link rel="apple-touch-icon" sizes="512x512" href="icon-512.png" />
  ```

* <span data-ttu-id="a2681-149">Добавьте следующий тег `<script>` в закрывающий тег `</body>` сразу после тега скрипта `blazor.webassembly.js`:</span><span class="sxs-lookup"><span data-stu-id="a2681-149">Add the following `<script>` tag inside the closing `</body>` tag immediately after the `blazor.webassembly.js` script tag:</span></span>

  ```html
      ...
      <script>navigator.serviceWorker.register('service-worker.js');</script>
  </body>
  ```

## <a name="installation-and-app-manifest"></a><span data-ttu-id="a2681-150">Установка и манифест приложения</span><span class="sxs-lookup"><span data-stu-id="a2681-150">Installation and app manifest</span></span>

<span data-ttu-id="a2681-151">При посещении приложения, созданного с использованием параметра шаблона прогрессивного веб-приложения, пользователи могут установить его в меню "Пуск", меню закрепления или на начальном экране своей операционной системы.</span><span class="sxs-lookup"><span data-stu-id="a2681-151">When visiting an app created using the PWA template, users have the option of installing the app into their OS's start menu, dock, or home screen.</span></span> <span data-ttu-id="a2681-152">Порядок применения этого параметра зависит от того, какой браузер используется.</span><span class="sxs-lookup"><span data-stu-id="a2681-152">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="a2681-153">В классических версиях браузеров на основе Chromium, таких как Microsoft Edge или Chrome, в строке URL-адреса появляется кнопка **Добавить**.</span><span class="sxs-lookup"><span data-stu-id="a2681-153">When using desktop Chromium-based browsers, such as Edge or Chrome, an **Add** button appears within the URL bar.</span></span> <span data-ttu-id="a2681-154">После того как пользователь нажмет кнопку **Добавить**, отобразится диалоговое окно подтверждения.</span><span class="sxs-lookup"><span data-stu-id="a2681-154">After the user selects the **Add** button, they receive a confirmation dialog:</span></span>

![Диалоговое окно подтверждения в Google Chrome с кнопкой "Установить" для приложения MyBlazorPwa.](progressive-web-app/_static/image2.png)

<span data-ttu-id="a2681-156">В iOS посетители могут установить прогрессивное веб-приложение с помощью кнопки **Поделиться** в браузере Safari, а также используя параметр **Добавить на главный экран**.</span><span class="sxs-lookup"><span data-stu-id="a2681-156">On iOS, visitors can install the PWA using Safari's **Share** button and its **Add to Homescreen** option.</span></span> <span data-ttu-id="a2681-157">В браузере Chrome для Android для этой цели следует нажать кнопку **Меню** в правом верхнем углу окна, а затем выбрать команду **Добавить на главный экран**.</span><span class="sxs-lookup"><span data-stu-id="a2681-157">On Chrome for Android, users should select the **Menu** button in the upper-right corner, followed by **Add to Home screen**.</span></span>

<span data-ttu-id="a2681-158">После установки приложение будет открываться в отдельном окне без адресной строки.</span><span class="sxs-lookup"><span data-stu-id="a2681-158">Once installed, the app appears in its own window without an address bar:</span></span>

![Приложение "MyBlazorPwa" в Google Chrome без адресной строки.](progressive-web-app/_static/image3.png)

<span data-ttu-id="a2681-160">Чтобы настроить заголовок окна, цветовую схему, значок или другие сведения, используйте файл `manifest.json` в каталоге `wwwroot` проекта.</span><span class="sxs-lookup"><span data-stu-id="a2681-160">To customize the window's title, color scheme, icon, or other details, see the `manifest.json` file in the project's `wwwroot` directory.</span></span> <span data-ttu-id="a2681-161">Схема этого файла соответствует веб-стандартам.</span><span class="sxs-lookup"><span data-stu-id="a2681-161">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="a2681-162">Дополнительные сведения см. в [веб-документации MDN: манифест веб-приложения](https://developer.mozilla.org/docs/Web/Manifest).</span><span class="sxs-lookup"><span data-stu-id="a2681-162">For more information, see [MDN web docs: Web App Manifest](https://developer.mozilla.org/docs/Web/Manifest).</span></span>

## <a name="offline-support"></a><span data-ttu-id="a2681-163">Поддержка автономной работы</span><span class="sxs-lookup"><span data-stu-id="a2681-163">Offline support</span></span>

<span data-ttu-id="a2681-164">По умолчанию приложения, созданные с помощью шаблона прогрессивного веб-приложения, поддерживают работу в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-164">By default, apps created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="a2681-165">Для этого пользователь должен сначала посетить приложение при наличии подключения к сети.</span><span class="sxs-lookup"><span data-stu-id="a2681-165">A user must first visit the app while they're online.</span></span> <span data-ttu-id="a2681-166">Браузер автоматически скачает и кэширует все ресурсы, необходимые для его работы в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-166">The browser automatically downloads and caches all of the resources required to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a2681-167">Поддержка разработки может помешать типовому циклу разработки, предусматривающему внесение изменений и их тестирование.</span><span class="sxs-lookup"><span data-stu-id="a2681-167">Development support would interfere with the usual development cycle of making changes and testing them.</span></span> <span data-ttu-id="a2681-168">Поэтому поддержка работы в автономном режиме доступна только для *опубликованных* приложений.</span><span class="sxs-lookup"><span data-stu-id="a2681-168">Therefore, offline support is only enabled for *published* apps.</span></span> 

> [!WARNING]
> <span data-ttu-id="a2681-169">Если вы планируете распространять прогрессивное веб-приложение с поддержкой автономного режима, следует обратить внимание на [несколько важных предупреждений и предостережений](#caveats-for-offline-pwas).</span><span class="sxs-lookup"><span data-stu-id="a2681-169">If you intend to distribute an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas).</span></span> <span data-ttu-id="a2681-170">Эти сценарии присущи всем поддерживающим автономную работу прогрессивным веб-приложениям и не являются специфичными для Blazor.</span><span class="sxs-lookup"><span data-stu-id="a2681-170">These scenarios are inherent to offline PWAs and not specific to Blazor.</span></span> <span data-ttu-id="a2681-171">Прежде чем планировать работу своего приложения, поддерживающего автономный режим, внимательно ознакомьтесь с этими предупреждениями и убедитесь, что они вам понятны.</span><span class="sxs-lookup"><span data-stu-id="a2681-171">Be sure to read and understand these caveats before making assumptions about how your offline-enabled app will work.</span></span>

<span data-ttu-id="a2681-172">Чтобы ознакомиться с принципами поддержки автономного режима:</span><span class="sxs-lookup"><span data-stu-id="a2681-172">To see how offline support works:</span></span>

1. <span data-ttu-id="a2681-173">Опубликуйте приложение.</span><span class="sxs-lookup"><span data-stu-id="a2681-173">Publish the app.</span></span> <span data-ttu-id="a2681-174">Для получения дополнительной информации см. <xref:blazor/host-and-deploy/index#publish-the-app>.</span><span class="sxs-lookup"><span data-stu-id="a2681-174">For more information, see <xref:blazor/host-and-deploy/index#publish-the-app>.</span></span>
1. <span data-ttu-id="a2681-175">Разверните приложение на сервере, который поддерживает протокол HTTPS, и получите доступ к приложению в браузере по его защищенному HTTPS-адресу.</span><span class="sxs-lookup"><span data-stu-id="a2681-175">Deploy the app to a server that supports HTTPS, and access the app in a browser at its secure HTTPS address.</span></span>
1. <span data-ttu-id="a2681-176">Откройте средства разработки браузера и убедитесь, что для узла на вкладке **Приложение** зарегистрирована *рабочая роль службы*.</span><span class="sxs-lookup"><span data-stu-id="a2681-176">Open the browser's dev tools and verify that a *Service Worker* is registered for the host on the **Application** tab:</span></span>

   ![Вкладка "Приложение" в средствах разработки Google Chrome с активированной и выполняемой рабочей ролью службы.](progressive-web-app/_static/image4.png)

1. <span data-ttu-id="a2681-178">Перезагрузите страницу и перейдите на вкладку **Сеть**. Для всех ресурсов страницы в качестве источников указаны **рабочая роль службы** или **кэш памяти**.</span><span class="sxs-lookup"><span data-stu-id="a2681-178">Reload the page and examine the **Network** tab. **Service Worker** or **memory cache** are listed as the sources for all of the page's assets:</span></span>

   ![Вкладка "Сеть" в средствах разработки Google Chrome с источниками для всех ресурсов страницы.](progressive-web-app/_static/image5.png)

1. <span data-ttu-id="a2681-180">Чтобы убедиться, что для загрузки приложения браузеру не требуется доступ к сети:</span><span class="sxs-lookup"><span data-stu-id="a2681-180">To verify that the browser isn't dependent on network access to load the app, either:</span></span>

   * <span data-ttu-id="a2681-181">Завершите работу веб-сервера и проверьте, как приложение продолжит работу в обычном режиме, включая перезагрузку страниц.</span><span class="sxs-lookup"><span data-stu-id="a2681-181">Shut down the web server and see how the app continues to function normally, which includes page reloads.</span></span> <span data-ttu-id="a2681-182">Аналогичным образом приложение продолжает обычную работу при снижении скорости сетевого подключения.</span><span class="sxs-lookup"><span data-stu-id="a2681-182">Likewise, the app continues to function normally when there's a slow network connection.</span></span>
   * <span data-ttu-id="a2681-183">Имитируйте работу в автономном режиме на вкладке **Сеть**.</span><span class="sxs-lookup"><span data-stu-id="a2681-183">Instruct the browser to simulate offline mode in the **Network** tab:</span></span>

   ![Вкладка "Сеть" в средствах разработки Google Chrome с раскрывающимся списком режимов браузера — изменяется с "В сети" на "Автономный".](progressive-web-app/_static/image6.png)

<span data-ttu-id="a2681-185">Поддержка работы в автономном режиме с помощью рабочей роли службы является веб-стандартом, не относящимся к Blazor.</span><span class="sxs-lookup"><span data-stu-id="a2681-185">Offline support using a service worker is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="a2681-186">Дополнительные сведения о рабочих ролях служб см. в [веб-документации MDN: API рабочей роли службы](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span><span class="sxs-lookup"><span data-stu-id="a2681-186">For more information on service workers, see [MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span></span> <span data-ttu-id="a2681-187">Дополнительные сведения об общих шаблонах использования рабочих ролей служб см. в статье [Google Web: жизненный цикл рабочей роли службы](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span><span class="sxs-lookup"><span data-stu-id="a2681-187">To learn more about common usage patterns for service workers, see [Google Web: The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

<span data-ttu-id="a2681-188">Шаблон прогрессивного веб-приложения Blazor создает два файла рабочей роли службы:</span><span class="sxs-lookup"><span data-stu-id="a2681-188">Blazor's PWA template produces two service worker files:</span></span>

* <span data-ttu-id="a2681-189">`wwwroot/service-worker.js`, который используется во время разработки;</span><span class="sxs-lookup"><span data-stu-id="a2681-189">`wwwroot/service-worker.js`, which is used during development.</span></span>
* <span data-ttu-id="a2681-190">`wwwroot/service-worker.published.js`, который используется после публикации приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-190">`wwwroot/service-worker.published.js`, which is used after the app is published.</span></span>

<span data-ttu-id="a2681-191">Чтобы использовать общую логику для этих двух файлов рабочих ролей службы, рассмотрите следующий подход.</span><span class="sxs-lookup"><span data-stu-id="a2681-191">To share logic between the two service worker files, consider the following approach:</span></span>

* <span data-ttu-id="a2681-192">Добавьте третий файл JavaScript для хранения общей логики.</span><span class="sxs-lookup"><span data-stu-id="a2681-192">Add a third JavaScript file to hold the common logic.</span></span>
* <span data-ttu-id="a2681-193">Используйте [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts), чтобы загрузить общую логику в оба файла рабочей роли службы.</span><span class="sxs-lookup"><span data-stu-id="a2681-193">Use [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load the common logic into both service worker files.</span></span>

### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="a2681-194">Стратегия первичного обращения к кэшу</span><span class="sxs-lookup"><span data-stu-id="a2681-194">Cache-first fetch strategy</span></span>

<span data-ttu-id="a2681-195">Встроенная рабочая роль службы `service-worker.published.js` выполняет разрешение запросов с применением стратегии *первичного обращения к кэшу*.</span><span class="sxs-lookup"><span data-stu-id="a2681-195">The built-in `service-worker.published.js` service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="a2681-196">Это означает, что даже при наличии доступа к сети или нового содержимого на сервере во всех возможных случаях рабочая роль службы отдает предпочтение возвращаемому из кэша содержимому.</span><span class="sxs-lookup"><span data-stu-id="a2681-196">This means that the service worker prefers to return cached content, regardless of whether the user has network access or newer content is available on the server.</span></span>

<span data-ttu-id="a2681-197">Такая стратегия полезна по следующим причинам.</span><span class="sxs-lookup"><span data-stu-id="a2681-197">The cache-first strategy is valuable because:</span></span>

* <span data-ttu-id="a2681-198">**Во-первых, за счет этого повышается надежность.**</span><span class="sxs-lookup"><span data-stu-id="a2681-198">**It ensures reliability.**</span></span> <span data-ttu-id="a2681-199">Состояние доступа к сети сложно определить однозначно,</span><span class="sxs-lookup"><span data-stu-id="a2681-199">Network access isn't a boolean state.</span></span> <span data-ttu-id="a2681-200">поскольку пользователь не всегда просто находится в подключенном или автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-200">A user isn't simply online or offline:</span></span>

  * <span data-ttu-id="a2681-201">Даже при наличии подключения его скорость может быть настолько мала, что ожидание загрузки содержимого может быть нецелесообразно.</span><span class="sxs-lookup"><span data-stu-id="a2681-201">The user's device may assume it's online, but the network might be so slow as to be impractical to wait for.</span></span>
  * <span data-ttu-id="a2681-202">Для некоторых URL-адресов из сети могут возвращаться недопустимые результаты, как, например, в случае с порталом перехвата Wi-Fi, который блокирует или перенаправляет определенные запросы.</span><span class="sxs-lookup"><span data-stu-id="a2681-202">The network might return invalid results for certain URLs, such as when there's a captive WIFI portal that's currently blocking or redirecting certain requests.</span></span>
  
  <span data-ttu-id="a2681-203">Именно поэтому API `navigator.onLine` браузера не может считаться надежным источником, на который следует полагаться в приложении.</span><span class="sxs-lookup"><span data-stu-id="a2681-203">This is why the browser's `navigator.onLine` API isn't reliable and shouldn't be depended upon.</span></span>

* <span data-ttu-id="a2681-204">**Во-вторых, это позволяет гарантировать корректность.**</span><span class="sxs-lookup"><span data-stu-id="a2681-204">**It ensures correctness.**</span></span> <span data-ttu-id="a2681-205">При создании кэша автономных ресурсов рабочая роль службы хэширует содержимое, чтобы гарантировать получение полного и согласованного моментального снимка ресурсов по состоянию на один конкретный момент времени.</span><span class="sxs-lookup"><span data-stu-id="a2681-205">When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="a2681-206">В дальнейшем этот кэш используется в качестве атомарной единицы.</span><span class="sxs-lookup"><span data-stu-id="a2681-206">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="a2681-207">Запрашивать более новые версии ресурсов из сети нецелесообразно, поскольку все данные, которые требуются, уже хранятся в кэше.</span><span class="sxs-lookup"><span data-stu-id="a2681-207">There's no point asking the network for newer resources, since the only versions required are the ones already cached.</span></span> <span data-ttu-id="a2681-208">Любые другие данные могут стать причиной несогласованности и несовместимости, например при попытке использовать версии сборок .NET, которые не компилировались вместе.</span><span class="sxs-lookup"><span data-stu-id="a2681-208">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that weren't compiled together).</span></span>

### <a name="background-updates"></a><span data-ttu-id="a2681-209">Обновления в фоновом режиме</span><span class="sxs-lookup"><span data-stu-id="a2681-209">Background updates</span></span>

<span data-ttu-id="a2681-210">Для наглядности прогрессивное веб-приложение с предпочтительным автономным режимом работы можно рассматривать как устанавливаемое мобильное приложение.</span><span class="sxs-lookup"><span data-stu-id="a2681-210">As a mental model, you can think of an offline-first PWA as behaving like a mobile app that can be installed.</span></span> <span data-ttu-id="a2681-211">Оно запускается немедленно, независимо от наличия сетевого подключения, однако при этом логика установленного приложения извлекается из моментального снимка на определенный момент времени, который может содержать устаревшие данные.</span><span class="sxs-lookup"><span data-stu-id="a2681-211">The app starts up immediately regardless of network connectivity, but the installed app logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="a2681-212">На основе шаблона прогрессивного веб-приложения Blazor создаются приложения, которые пытаются автоматически выполнить обновление в фоновом режиме при наличии работающего сетевого подключения каждый раз, когда приложение посещает пользователь.</span><span class="sxs-lookup"><span data-stu-id="a2681-212">The Blazor PWA template produces apps that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="a2681-213">Этот процесс реализуется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a2681-213">The way this works is as follows:</span></span>

* <span data-ttu-id="a2681-214">Во время компиляции проект создает *манифест ресурсов рабочей роли службы*.</span><span class="sxs-lookup"><span data-stu-id="a2681-214">During compilation, the project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="a2681-215">По умолчанию это `service-worker-assets.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-215">By default, this is called `service-worker-assets.js`.</span></span> <span data-ttu-id="a2681-216">В нем перечислены все статические ресурсы, которые требуются для работы приложения в автономном режиме, например сборки .NET, файлы JavaScript и каскадные таблицы стилей, в том числе хэши содержимого.</span><span class="sxs-lookup"><span data-stu-id="a2681-216">The manifest lists all the static resources that the app requires to function offline, such as .NET assemblies, JavaScript files, and CSS, including their content hashes.</span></span> <span data-ttu-id="a2681-217">Рабочая роль службы загружает список ресурсов и использует его для определения ресурсов, которые требуется кэшировать.</span><span class="sxs-lookup"><span data-stu-id="a2681-217">The resource list is loaded by the service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="a2681-218">Каждый раз, когда пользователь открывает приложение, браузер повторно запрашивает `service-worker.js` и `service-worker-assets.js` в фоновом режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-218">Each time the user visits the app, the browser re-requests `service-worker.js` and `service-worker-assets.js` in the background.</span></span> <span data-ttu-id="a2681-219">Файлы сравниваются побайтово с существующей установленной рабочей ролью службы.</span><span class="sxs-lookup"><span data-stu-id="a2681-219">The files are compared byte-for-byte with the existing installed service worker.</span></span> <span data-ttu-id="a2681-220">Если сервер возвращает измененное содержимое для любого из этих файлов, рабочая роль службы пытается установить собственную новую версию.</span><span class="sxs-lookup"><span data-stu-id="a2681-220">If the server returns changed content for either of these files, the service worker attempts to install a new version of itself.</span></span>
* <span data-ttu-id="a2681-221">При установке собственной новой версии рабочая роль службы создает новый отдельный кэш для автономных ресурсов и начинает заполнять кэш ресурсами, перечисленными в файле `service-worker-assets.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-221">When installing a new version of itself, the service worker creates a new, separate cache for offline resources and starts populating the cache with resources listed in `service-worker-assets.js`.</span></span> <span data-ttu-id="a2681-222">Эта логика реализуется в функции `onInstall` в файле `service-worker.published.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-222">This logic is implemented in the `onInstall` function inside `service-worker.published.js`.</span></span>
* <span data-ttu-id="a2681-223">Процесс завершается успешно, когда все ресурсы загружаются без ошибок и все хэши содержимого совпадают.</span><span class="sxs-lookup"><span data-stu-id="a2681-223">The process completes successfully when all of the resources are loaded without error and all content hashes match.</span></span> <span data-ttu-id="a2681-224">В случае успешного выполнения новая рабочая роль службы переходит в состояние *ожидания активации*.</span><span class="sxs-lookup"><span data-stu-id="a2681-224">If successful, the new service worker enters a *waiting for activation* state.</span></span> <span data-ttu-id="a2681-225">Как только пользователь закроет приложение (т. е. все вкладки или окна, в которых оно отображается), новая рабочая роль службы становится *активной* и используется при последующем посещении приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-225">As soon as the user closes the app (no remaining app tabs or windows), the new service worker becomes *active* and is used for subsequent app visits.</span></span> <span data-ttu-id="a2681-226">Старая рабочая роль службы и ее кэш при этом удаляются.</span><span class="sxs-lookup"><span data-stu-id="a2681-226">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="a2681-227">Если процесс завершается неудачно, новый экземпляр рабочей роли службы отклоняется.</span><span class="sxs-lookup"><span data-stu-id="a2681-227">If the process doesn't complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="a2681-228">При следующем посещении пользователя будет предпринята попытка выполнить процесс обновления еще раз в расчете на более высокое качество сетевого подключения и возможность выполнения необходимых запросов.</span><span class="sxs-lookup"><span data-stu-id="a2681-228">The update process is attempted again on the user's next visit, when hopefully the client has a better network connection that can complete the requests.</span></span>

<span data-ttu-id="a2681-229">Настроить этот процесс можно, используя логику рабочей роли службы.</span><span class="sxs-lookup"><span data-stu-id="a2681-229">Customize this process by editing the service worker logic.</span></span> <span data-ttu-id="a2681-230">Все перечисленные выше варианты не являются специфичными для Blazor, однако описывают стандартный способ использования шаблона прогрессивного веб-приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-230">None of the preceding behavior is specific to Blazor but is merely the default experience provided by the PWA template option.</span></span> <span data-ttu-id="a2681-231">Дополнительные сведения см. в [веб-документации MDN: API рабочей роли службы](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span><span class="sxs-lookup"><span data-stu-id="a2681-231">For more information, see [MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span></span>

### <a name="how-requests-are-resolved"></a><span data-ttu-id="a2681-232">Принципы разрешения запросов</span><span class="sxs-lookup"><span data-stu-id="a2681-232">How requests are resolved</span></span>

<span data-ttu-id="a2681-233">Как описывается выше в разделе [Стратегия первичного обращения к кэшу](#cache-first-fetch-strategy), по умолчанию рабочая роль службы применяет стратегию *первичного обращения к кэшу*, то есть пытается по возможности всегда использовать кэшированное содержимое.</span><span class="sxs-lookup"><span data-stu-id="a2681-233">As described in the [Cache-first fetch strategy](#cache-first-fetch-strategy) section, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="a2681-234">Если для отдельного URL-адреса кэшированное содержимое отсутствует (например, в случае запроса данных из серверного API), рабочая роль службы использует обычные сетевые запросы,</span><span class="sxs-lookup"><span data-stu-id="a2681-234">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request.</span></span> <span data-ttu-id="a2681-235">которые выполняются успешно только при наличии доступа к серверу.</span><span class="sxs-lookup"><span data-stu-id="a2681-235">The network request succeeds if the server is reachable.</span></span> <span data-ttu-id="a2681-236">Эта логика реализуется в функции `onFetch` в файле `service-worker.published.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-236">This logic is implemented inside `onFetch` function within `service-worker.published.js`.</span></span>

<span data-ttu-id="a2681-237">Если компоненты приложения Razor запрашивают данные из серверных API и вам требуется удобный пользовательский интерфейс для обработки сбоев, связанных с отсутствием доступа к сети, то соответствующую логику необходимо реализовать в самих компонентах приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-237">If the app's Razor components rely on requesting data from backend APIs and you want to provide a friendly user experience for failed requests due to network unavailability, implement logic within the app's components.</span></span> <span data-ttu-id="a2681-238">Например, используйте `try/catch` для запросов <xref:System.Net.Http.HttpClient>.</span><span class="sxs-lookup"><span data-stu-id="a2681-238">For example, use `try/catch` around <xref:System.Net.Http.HttpClient> requests.</span></span>

### <a name="support-server-rendered-pages"></a><span data-ttu-id="a2681-239">Поддержка страниц, подготавливаемых к просмотру на сервере</span><span class="sxs-lookup"><span data-stu-id="a2681-239">Support server-rendered pages</span></span>

<span data-ttu-id="a2681-240">Рассмотрим, что происходит при первом переходе пользователя к URL-адресу, например к `/counter`, или по любой другой прямой ссылке в приложении.</span><span class="sxs-lookup"><span data-stu-id="a2681-240">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link in the app.</span></span> <span data-ttu-id="a2681-241">В таких случаях вам не нужно возвращать кэшированное содержимое как `/counter`. Вместо этого нужно загрузить в браузер содержимое, кэшированное как `/index.html`, для запуска приложения Blazor WebAssembly.</span><span class="sxs-lookup"><span data-stu-id="a2681-241">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly app.</span></span> <span data-ttu-id="a2681-242">Такие начальные запросы называются *запросами навигации* в отличие от следующих запросов:</span><span class="sxs-lookup"><span data-stu-id="a2681-242">These initial requests are known as *navigation* requests, as opposed to:</span></span>

* <span data-ttu-id="a2681-243">запросов `subresource` для получения изображений, таблиц стилей или других файлов;</span><span class="sxs-lookup"><span data-stu-id="a2681-243">`subresource` requests for images, stylesheets, or other files.</span></span>
* <span data-ttu-id="a2681-244">запросов `fetch/XHR` для получения данных API.</span><span class="sxs-lookup"><span data-stu-id="a2681-244">`fetch/XHR` requests for API data.</span></span>

<span data-ttu-id="a2681-245">По умолчанию рабочая роль службы использует для обработки запросов навигации специальную логику.</span><span class="sxs-lookup"><span data-stu-id="a2681-245">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="a2681-246">Рабочая роль службы разрешает такие запросы путем возврата кэшированного содержимого для `/index.html`, независимо от того, какой URL-адрес запрашивается.</span><span class="sxs-lookup"><span data-stu-id="a2681-246">The service worker resolves the requests by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="a2681-247">Эта логика реализуется в функции `onFetch` в файле `service-worker.published.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-247">This logic is implemented in the `onFetch` function inside `service-worker.published.js`.</span></span>

<span data-ttu-id="a2681-248">Если для некоторых URL-адресов в вашем приложении должен возвращаться подготавливаемый к просмотру на сервере код HTML (то есть для обслуживания `/index.html` не должен использоваться кэш), вам потребуется изменить логику рабочей роли службы.</span><span class="sxs-lookup"><span data-stu-id="a2681-248">If your app has certain URLs that must return server-rendered HTML, and not serve `/index.html` from the cache, then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="a2681-249">Если все URL-адреса, содержащие `/Identity/`, требуется обрабатывать как обычные сетевые запросы к серверу, следует изменить логику функции `onFetch` в файле `service-worker.published.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-249">If all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify `service-worker.published.js` `onFetch` logic.</span></span> <span data-ttu-id="a2681-250">Найдите следующий код.</span><span class="sxs-lookup"><span data-stu-id="a2681-250">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="a2681-251">Измените код следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a2681-251">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
  && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="a2681-252">Если этого не сделать, то, независимо от наличия сетевого подключения, рабочая роль службы будет перехватывать запросы к таким URL-адресам и разрешать их с помощью `/index.html`.</span><span class="sxs-lookup"><span data-stu-id="a2681-252">If you don't do this, then regardless of network connectivity, the service worker intercepts requests for such URLs and resolves them using `/index.html`.</span></span>

<span data-ttu-id="a2681-253">Добавьте в проверку конечные точки для внешних поставщиков проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="a2681-253">Add additional endpoints for external authentication providers to the check.</span></span> <span data-ttu-id="a2681-254">В следующем примере в проверку добавляется `/signin-google` для проверки подлинности Google:</span><span class="sxs-lookup"><span data-stu-id="a2681-254">In the following example, `/signin-google` for Google authentication is added to the check:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
  && !event.request.url.includes('/Identity/')
  && !event.request.url.includes('/signin-google');
```

<span data-ttu-id="a2681-255">Не требуется выполнять никаких действий для среды разработки, где содержимое всегда извлекается из сети.</span><span class="sxs-lookup"><span data-stu-id="a2681-255">No action is required for the Development environment, where content is always fetched from the network.</span></span>

### <a name="control-asset-caching"></a><span data-ttu-id="a2681-256">Управление кэшированием ресурсов</span><span class="sxs-lookup"><span data-stu-id="a2681-256">Control asset caching</span></span>

<span data-ttu-id="a2681-257">Если в вашем проекте определено свойство MSBuild `ServiceWorkerAssetsManifest`, средства сборки Blazor создадут манифест ресурса рабочей роли службы с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="a2681-257">If your project defines the `ServiceWorkerAssetsManifest` MSBuild property, Blazor's build tooling generates a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="a2681-258">По умолчанию шаблон прогрессивного веб-приложения создает файл проекта со следующим свойством.</span><span class="sxs-lookup"><span data-stu-id="a2681-258">The default PWA template produces a project file containing the following property:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="a2681-259">Этот файл помещается в выходной каталог `wwwroot`, откуда браузер может извлекать его посредством запроса `/service-worker-assets.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-259">The file is placed in the `wwwroot` output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="a2681-260">Чтобы просмотреть содержимое этого файла, откройте `/bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js` в текстовом редакторе.</span><span class="sxs-lookup"><span data-stu-id="a2681-260">To see the contents of this file, open `/bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js` in a text editor.</span></span> <span data-ttu-id="a2681-261">Не вносите изменения в этот файл, поскольку он создается заново при каждой сборке.</span><span class="sxs-lookup"><span data-stu-id="a2681-261">However, don't edit the file, as it's regenerated on each build.</span></span>

<span data-ttu-id="a2681-262">По умолчанию этот манифест содержит следующие данные:</span><span class="sxs-lookup"><span data-stu-id="a2681-262">By default, this manifest lists:</span></span>

* <span data-ttu-id="a2681-263">Все управляемые Blazor ресурсы, в том числе сборки .NET и файлы среды выполнения .NET WebAssembly, которые требуются для работы в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-263">Any Blazor-managed resources, such as .NET assemblies and the .NET WebAssembly runtime files required to function offline.</span></span>
* <span data-ttu-id="a2681-264">Все ресурсы, которые будут опубликованы в каталоге `wwwroot` приложения, такие как изображения, таблицы стилей и файлы JavaScript. К ним также относятся статические веб-ресурсы, предоставляемые в составе внешних проектов и пакетов NuGet.</span><span class="sxs-lookup"><span data-stu-id="a2681-264">All resources for publishing to the app's `wwwroot` directory, such as images, stylesheets, and JavaScript files, including static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="a2681-265">Чтобы управлять получением и кэшированием этих ресурсов в рабочей роли службы, измените логику функции `onInstall` в файле `service-worker.published.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-265">You can control which of these resources are fetched and cached by the service worker by editing the logic in `onInstall` in `service-worker.published.js`.</span></span> <span data-ttu-id="a2681-266">По умолчанию рабочая роль службы получает и кэширует файлы с типичными для веб-файлов расширениями, такими как `.html`, `.css`, `.js` и `.wasm`, а также характерные для Blazor WebAssembly файлы (`.dll`, `.pdb`).</span><span class="sxs-lookup"><span data-stu-id="a2681-266">By default, the service worker fetches and caches files matching typical web filename extensions such as `.html`, `.css`, `.js`, and `.wasm`, plus file types specific to Blazor WebAssembly (`.dll`, `.pdb`).</span></span>

<span data-ttu-id="a2681-267">Чтобы включить другие ресурсы, отсутствующие в каталоге `wwwroot` приложения, определите дополнительные записи `ItemGroup` MSBuild, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="a2681-267">To include additional resources that aren't present in the app's `wwwroot` directory, define extra MSBuild `ItemGroup` entries, as shown in the following example:</span></span>

```xml
<ItemGroup>
  <ServiceWorkerAssetsManifestItem Include="MyDirectory\AnotherFile.json"
    RelativePath="MyDirectory\AnotherFile.json" AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="a2681-268">В метаданных `AssetUrl` указывается относительный URL-адрес, который браузер должен использовать при получении ресурса в кэш.</span><span class="sxs-lookup"><span data-stu-id="a2681-268">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="a2681-269">При этом имя оригинального исходного файла на диске может не учитываться.</span><span class="sxs-lookup"><span data-stu-id="a2681-269">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="a2681-270">Добавление `ServiceWorkerAssetsManifestItem` не приводит к публикации файла в каталог `wwwroot` приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-270">Adding a `ServiceWorkerAssetsManifestItem` doesn't cause the file to be published in the app's `wwwroot` directory.</span></span> <span data-ttu-id="a2681-271">Управление выходными данными публикации следует организовать отдельно.</span><span class="sxs-lookup"><span data-stu-id="a2681-271">The publish output must be controlled separately.</span></span> <span data-ttu-id="a2681-272">В результате добавления `ServiceWorkerAssetsManifestItem` в манифесте ресурса рабочей роли службы лишь появляется дополнительная запись.</span><span class="sxs-lookup"><span data-stu-id="a2681-272">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="a2681-273">Push-уведомления</span><span class="sxs-lookup"><span data-stu-id="a2681-273">Push notifications</span></span>

<span data-ttu-id="a2681-274">Как и любые аналоги, прогрессивные веб-приложения Blazor WebAssembly поддерживают получение push-уведомлений от внутреннего сервера.</span><span class="sxs-lookup"><span data-stu-id="a2681-274">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="a2681-275">Сервер может отправлять такие уведомления в любое время, даже если приложение не используется активно</span><span class="sxs-lookup"><span data-stu-id="a2681-275">The server can send push notifications at any time, even when the user isn't actively using the app.</span></span> <span data-ttu-id="a2681-276">(например, если другой пользователь выполняет действие, о котором требуется оповестить).</span><span class="sxs-lookup"><span data-stu-id="a2681-276">For example, push notifications can be sent when a different user performs a relevant action.</span></span>

<span data-ttu-id="a2681-277">Механизм отправки push-уведомлений не зависит от Blazor WebAssembly, так как он реализуется на внутреннем сервере, который может использовать любую технологию.</span><span class="sxs-lookup"><span data-stu-id="a2681-277">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="a2681-278">Для отправки push-уведомлений с сервера ASP.NET Core рекомендуется [использовать методику, аналогичную описываемой в рамках семинара по проекту Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span><span class="sxs-lookup"><span data-stu-id="a2681-278">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to the approach taken in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="a2681-279">Механизм приема и отображения push-уведомлений на стороне клиента также реализуется независимо от Blazor WebAssembly в файле JavaScript рабочей роли службы.</span><span class="sxs-lookup"><span data-stu-id="a2681-279">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker JavaScript file.</span></span> <span data-ttu-id="a2681-280">Рекомендуем обратиться к [семинару, посвященному проекту Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span><span class="sxs-lookup"><span data-stu-id="a2681-280">For an example, see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="a2681-281">Предупреждения относительно прогрессивных веб-приложений с поддержкой автономной работы</span><span class="sxs-lookup"><span data-stu-id="a2681-281">Caveats for offline PWAs</span></span>

<span data-ttu-id="a2681-282">Поддержка работы в автономном режиме требуется не для всех приложений.</span><span class="sxs-lookup"><span data-stu-id="a2681-282">Not all apps should attempt to support offline use.</span></span> <span data-ttu-id="a2681-283">С ее реализацией сопряжены определенные сложности, решение которых не всегда целесообразно.</span><span class="sxs-lookup"><span data-stu-id="a2681-283">Offline support adds significant complexity, while not always being relevant for the use cases required.</span></span>

<span data-ttu-id="a2681-284">Поддержка автономной работы как правило требуется лишь в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="a2681-284">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="a2681-285">Браузер использует преимущественно локальное основное хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="a2681-285">If the primary data store is local to the browser.</span></span> <span data-ttu-id="a2681-286">В качестве примера можно привести разработку пользовательского интерфейса для устройства [Интернета вещей](https://en.wikipedia.org/wiki/Internet_of_things), которое хранит данные в `localStorage` или [индексированной базе данных](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span><span class="sxs-lookup"><span data-stu-id="a2681-286">For example, the approach is relevant in an app with a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>
* <span data-ttu-id="a2681-287">Приложение тратит значительный объем ресурсов на получение и кэширование данных серверного API для каждого пользователя, чтобы они могли работать с такими данными в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-287">If the app performs a significant amount of work to fetch and cache the backend API data relevant to each user so that they can navigate through the data offline.</span></span> <span data-ttu-id="a2681-288">Если приложение должно поддерживать редактирование, потребуется создать систему, которая будет отслеживать изменения и синхронизировать их с серверной частью.</span><span class="sxs-lookup"><span data-stu-id="a2681-288">If the app must support editing, a system for tracking changes and synchronizing data with the backend must be built.</span></span>
* <span data-ttu-id="a2681-289">Необходимо гарантировать мгновенную загрузку приложения независимо от состояния сетевого подключения.</span><span class="sxs-lookup"><span data-stu-id="a2681-289">If the goal is to guarantee that the app loads immediately regardless of network conditions.</span></span> <span data-ttu-id="a2681-290">Реализуйте соответствующий пользовательский интерфейс для работы с запросами к серверному API и корректного разрешения ситуаций, когда они завершаются сбоем из-за отсутствия доступа к сети.</span><span class="sxs-lookup"><span data-stu-id="a2681-290">Implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when requests fail due to network unavailability.</span></span>

<span data-ttu-id="a2681-291">Кроме того, поддержка работы в автономном режиме для прогрессивных веб-приложений сопряжена с рядом дополнительных сложностей.</span><span class="sxs-lookup"><span data-stu-id="a2681-291">Additionally, offline-capable PWAs must deal with a range of additional complications.</span></span> <span data-ttu-id="a2681-292">Разработчикам следует внимательно изучить предостережения, приведенные в разделах ниже.</span><span class="sxs-lookup"><span data-stu-id="a2681-292">Developers should carefully familiarize themselves with the caveats in the following sections.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="a2681-293">Работа в автономном режиме поддерживается только для опубликованных приложений</span><span class="sxs-lookup"><span data-stu-id="a2681-293">Offline support only when published</span></span>

<span data-ttu-id="a2681-294">В процессе разработки каждое изменение, как правило, должно сразу отражаться в браузере, не дожидаясь обновления в фоновом режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-294">During development you typically want to see each change reflected immediately in the browser without going through a background update process.</span></span> <span data-ttu-id="a2681-295">Поэтому шаблон прогрессивного веб-приложения Blazor обеспечивает поддержку автономной работы только после публикации приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-295">Therefore, Blazor's PWA template enables offline support only when published.</span></span>

<span data-ttu-id="a2681-296">При создании приложения, поддерживающего автономную работу, недостаточно протестировать его в режиме разработки.</span><span class="sxs-lookup"><span data-stu-id="a2681-296">When building an offline-capable app, it's not enough to test the app in the Development environment.</span></span> <span data-ttu-id="a2681-297">Вам придется проверить приложение в опубликованном состоянии, чтобы понять, как оно будет вести себя при различных состояниях сети.</span><span class="sxs-lookup"><span data-stu-id="a2681-297">You must test the app in its published state to understand how it responds to different network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="a2681-298">Обновление выполняется только после выхода пользователя из приложения</span><span class="sxs-lookup"><span data-stu-id="a2681-298">Update completion after user navigation away from app</span></span>

<span data-ttu-id="a2681-299">Обновления будут выполняться только после того, как пользователь выйдет из приложения на всех вкладках.</span><span class="sxs-lookup"><span data-stu-id="a2681-299">Updates don't complete until the user has navigated away from the app in all tabs.</span></span> <span data-ttu-id="a2681-300">Как поясняется в разделе [Обновления в фоновом режиме](#background-updates), после развертывания и обновления приложения браузер получит обновленные файлы рабочей роли службы, чтобы запустить процесс обновления.</span><span class="sxs-lookup"><span data-stu-id="a2681-300">As explained in the [Background updates](#background-updates) section, after you deploy an update to the app, the browser fetches the updated service worker files to begin the update process.</span></span>

<span data-ttu-id="a2681-301">Однако далеко не все разработчики знают, что даже после завершения процесса обновления оно вступит в силу **только после того**, как пользователь выйдет из приложения на всех вкладках.</span><span class="sxs-lookup"><span data-stu-id="a2681-301">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="a2681-302">Даже если ваше приложение отображается только в одной вкладке, простого ее обновления будет **недостаточно**.</span><span class="sxs-lookup"><span data-stu-id="a2681-302">It is **not** sufficient to refresh the tab displaying the app, even if it's the only tab displaying the app.</span></span> <span data-ttu-id="a2681-303">Пока пользователь не закроет приложение полностью, новая рабочая роль службы будет оставаться в состоянии *ожидания активации*.</span><span class="sxs-lookup"><span data-stu-id="a2681-303">Until your app is completely closed, the new service worker remains in the *waiting to activate* status.</span></span> <span data-ttu-id="a2681-304">**Такое поведение присуще всем веб-платформам и не является специфичным для Blazor.**</span><span class="sxs-lookup"><span data-stu-id="a2681-304">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="a2681-305">Соответственно, многие разработчики сталкиваются с проблемами при попытке протестировать обновления рабочей роли службы или кэшированных автономно ресурсов.</span><span class="sxs-lookup"><span data-stu-id="a2681-305">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="a2681-306">Открыв средства разработчика в браузере, вы можете увидеть нечто подобное:</span><span class="sxs-lookup"><span data-stu-id="a2681-306">If you check in the browser's developer tools, you may see something like the following:</span></span>

![Вкладка "Приложение" в Google Chrome с рабочей ролью службы приложения в состоянии ожидания активации.](progressive-web-app/_static/image7.png)

<span data-ttu-id="a2681-308">Рабочая роль будет находиться в состоянии ожидания до тех пор, пока список "клиентов" (т. е. вкладок или окон, в которых отображается приложение) не опустеет.</span><span class="sxs-lookup"><span data-stu-id="a2681-308">For as long as the list of "clients," which are tabs or windows displaying your app, is nonempty, the worker continues waiting.</span></span> <span data-ttu-id="a2681-309">Это необходимо для обеспечения согласованности.</span><span class="sxs-lookup"><span data-stu-id="a2681-309">The reason service workers do this is to guarantee consistency.</span></span> <span data-ttu-id="a2681-310">Согласованность означает получение всех ресурсов из одного атомарного кэша.</span><span class="sxs-lookup"><span data-stu-id="a2681-310">Consistency means that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="a2681-311">При тестировании изменений может быть удобно воспользоваться ссылкой skipWaiting, которая позволяет пропустить этап ожидания (см. снимок экрана выше), и затем перезагрузить страницу.</span><span class="sxs-lookup"><span data-stu-id="a2681-311">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the preceding screenshot, then reload the page.</span></span> <span data-ttu-id="a2681-312">Можно автоматизировать этот процесс для всех пользователей, реализовав в коде рабочей роли службы [пропуск этапа "ожидания" с немедленной активацией обновления](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span><span class="sxs-lookup"><span data-stu-id="a2681-312">You can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="a2681-313">Если пропустить этап ожидания, согласованное получение ресурсов из одного и того же экземпляра кэша не гарантируется.</span><span class="sxs-lookup"><span data-stu-id="a2681-313">If you skip the waiting phase, you're giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="a2681-314">Пользователи могут запускать любую ранее существовавшую версию приложения</span><span class="sxs-lookup"><span data-stu-id="a2681-314">Users may run any historical version of the app</span></span>

<span data-ttu-id="a2681-315">Как правило, разработчики веб-приложения ожидают, что пользователи будут работать только с его последней развернутой версией, поскольку это характерно для традиционной модели распространения.</span><span class="sxs-lookup"><span data-stu-id="a2681-315">Web developers habitually expect that users only run the latest deployed version of their web app, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="a2681-316">Тем не менее прогрессивное веб-приложение с предпочтительным автономным режимом работы в этом отношении больше похоже на собственное мобильное приложение, пользователи которого далеко не всегда работают с последней версией.</span><span class="sxs-lookup"><span data-stu-id="a2681-316">However, an offline-first PWA is more akin to a native mobile app, where users aren't necessarily running the latest version.</span></span>

<span data-ttu-id="a2681-317">Как описывается в разделе [Обновления в фоновом режиме](#background-updates), после развертывания обновления для приложения **все его текущие пользователи будут работать с предыдущей версией как минимум во время ближайшего посещения**, поскольку обновление происходит в фоновом режиме только после того, как пользователь выйдет из приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-317">As explained in the [Background updates](#background-updates) section, after you deploy an update to your app, **each existing user continues to use a previous version for at least one further visit** because the update occurs in the background and isn't activated until the user thereafter navigates away.</span></span> <span data-ttu-id="a2681-318">Кроме того, в этом случае предыдущей используемой версией не обязательно будет та, которую вы развернули в прошлый раз.</span><span class="sxs-lookup"><span data-stu-id="a2681-318">Plus, the previous version being used isn't necessarily the previous one you deployed.</span></span> <span data-ttu-id="a2681-319">В зависимости от того, когда пользователь последний раз выполнял обновление, это может быть *любая* ранее существовавшая версия.</span><span class="sxs-lookup"><span data-stu-id="a2681-319">The previous version can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="a2681-320">Таким образом, если внешние и внутренние компоненты приложения должны использовать согласованную схему для работы с запросами к API, это может привести к возникновению проблем.</span><span class="sxs-lookup"><span data-stu-id="a2681-320">This can be an issue if the frontend and backend parts of your app require agreement about the schema for API requests.</span></span> <span data-ttu-id="a2681-321">Соответственно, развертывать изменения схемы API, не предусматривающие обратную совместимость, можно только после того, как вы убедитесь, что все пользователи выполнили обновление.</span><span class="sxs-lookup"><span data-stu-id="a2681-321">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded.</span></span> <span data-ttu-id="a2681-322">Также в таких случаях можно явно запретить использование несовместимых старых версий приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-322">Alternatively, block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="a2681-323">Это требование к сценарию аналогично тому, которое применяется для собственных мобильных приложений.</span><span class="sxs-lookup"><span data-stu-id="a2681-323">This scenario requirement is the same as for native mobile apps.</span></span> <span data-ttu-id="a2681-324">При развертывании существенных изменений в серверных API пользователи, не выполнившие обновление, столкнутся со сбоями в работе клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="a2681-324">If you deploy a breaking change in server APIs, the client app is broken for users who haven't yet updated.</span></span>

<span data-ttu-id="a2681-325">Соответственно, по возможности не следует развертывать существенные изменения в серверных API.</span><span class="sxs-lookup"><span data-stu-id="a2681-325">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="a2681-326">Если это все же необходимо, рекомендуется использовать [стандартные API рабочей роли службы, такие как ServiceWorkerRegistration](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration), для определения актуальности версии приложения и блокировки его старых версий.</span><span class="sxs-lookup"><span data-stu-id="a2681-326">If you must do so, consider using [standard Service Worker APIs such as ServiceWorkerRegistration](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the app is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="a2681-327">Возникают помехи в работе подготавливаемых к просмотру на сервере страниц</span><span class="sxs-lookup"><span data-stu-id="a2681-327">Interference with server-rendered pages</span></span>

<span data-ttu-id="a2681-328">Как описывается выше в разделе [Поддержка страниц, подготавливаемых к просмотру на сервере](#support-server-rendered-pages), чтобы обойти поведение рабочей роли службы и предотвратить возврат содержимого `/index.html` для всех запросов навигации, измените логику рабочей роли службы.</span><span class="sxs-lookup"><span data-stu-id="a2681-328">As described in the [Support server-rendered pages](#support-server-rendered-pages) section, if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="a2681-329">По умолчанию кэшируется все содержимое манифеста ресурса рабочей роли службы</span><span class="sxs-lookup"><span data-stu-id="a2681-329">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="a2681-330">Как описывается выше в разделе [Управление кэшированием ресурсов](#control-asset-caching), файл `service-worker-assets.js` создается в процессе сборки и содержит список всех ресурсов, которые должна получать и кэшировать рабочая роль службы.</span><span class="sxs-lookup"><span data-stu-id="a2681-330">As described in the [Control asset caching](#control-asset-caching) section, the file `service-worker-assets.js` is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="a2681-331">Поскольку в этот список по умолчанию включается все содержимое, размещаемое в каталоге `wwwroot`, в том числе и поступающее из внешних пакетов и проектов, необходимо тщательно следить за тем, чтобы в этом каталоге не было слишком много содержимого.</span><span class="sxs-lookup"><span data-stu-id="a2681-331">Since this list by default includes everything emitted to `wwwroot`, including content supplied by external packages and projects, you must be careful not to put too much content there.</span></span> <span data-ttu-id="a2681-332">Если каталог `wwwroot` содержит несколько миллионов изображений, рабочая роль службы попытается получить и кэшировать их все, что приведет к перегрузке сети и, скорее всего, закончится сбоем.</span><span class="sxs-lookup"><span data-stu-id="a2681-332">If the `wwwroot` directory contains millions of images, the service worker tries to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="a2681-333">Реализуйте произвольную логику, ограничивающую получение и кэширование содержимого манифеста, внеся соответствующие изменения в функцию `onInstall` в файле `service-worker.published.js`.</span><span class="sxs-lookup"><span data-stu-id="a2681-333">Implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in `service-worker.published.js`.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="a2681-334">Взаимодействие с технологиями проверки подлинности</span><span class="sxs-lookup"><span data-stu-id="a2681-334">Interaction with authentication</span></span>

<span data-ttu-id="a2681-335">Шаблон PWA можно использовать вместе с проверкой подлинности.</span><span class="sxs-lookup"><span data-stu-id="a2681-335">The PWA template can be used in conjunction with authentication.</span></span> <span data-ttu-id="a2681-336">Прогрессивные веб-приложения с поддержкой автономной работы также могут обеспечивать проверку подлинности при наличии у пользователя начального подключения к сети.</span><span class="sxs-lookup"><span data-stu-id="a2681-336">An offline-capable PWA can also support authentication when the user has initial network connectivity.</span></span>

<span data-ttu-id="a2681-337">В случае отсутствия сетевого подключения пользователь не сможет пройти проверку подлинности или получить маркеры доступа.</span><span class="sxs-lookup"><span data-stu-id="a2681-337">When a user doesn't have network connectivity, they can't authenticate or obtain access tokens.</span></span> <span data-ttu-id="a2681-338">По умолчанию при попытке перейти на страницу входа при отсутствии доступа к сети будет отображаться сообщение об ошибке сети.</span><span class="sxs-lookup"><span data-stu-id="a2681-338">By default, attempting to visit the login page without network access results in a "network error" message.</span></span> <span data-ttu-id="a2681-339">Необходимо организовать работу пользователя в автономном режиме таким образом, чтобы для выполнения задач при отсутствии сетевого подключения не требовались маркеры доступа или проверка подлинности.</span><span class="sxs-lookup"><span data-stu-id="a2681-339">You must design a UI flow that allows the user perform useful tasks while offline without attempting to authenticate the user or obtain access tokens.</span></span> <span data-ttu-id="a2681-340">Либо должны быть предусмотрены способы минимизировать последствия сбоев в таких случаях.</span><span class="sxs-lookup"><span data-stu-id="a2681-340">Alternatively, you can design the app to gracefully fail when the network isn't available.</span></span> <span data-ttu-id="a2681-341">Если реализовать это в приложении невозможно, следует задуматься, действительно ли в нем необходима поддержка работы в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-341">If the app can't be designed to handle these scenarios, you might not want to enable offline support.</span></span>

<span data-ttu-id="a2681-342">Если приложение, предназначенное для работы в сети и в автономном режиме, снова подключено к сети:</span><span class="sxs-lookup"><span data-stu-id="a2681-342">When an app that's designed for online and offline use is online again:</span></span>

* <span data-ttu-id="a2681-343">приложению может потребоваться подготовить новый маркер доступа;</span><span class="sxs-lookup"><span data-stu-id="a2681-343">The app might need to provision a new access token.</span></span>
* <span data-ttu-id="a2681-344">приложение должно определить, вошел ли другой пользователь в службу, чтобы применить к учетной записи пользователя операции, выполненные в автономном режиме.</span><span class="sxs-lookup"><span data-stu-id="a2681-344">The app must detect if a different user is signed into the service so that it can apply operations to the user's account that were made while they were offline.</span></span>

<span data-ttu-id="a2681-345">Чтобы создать автономное приложение PWA, взаимодействующее с проверкой подлинности:</span><span class="sxs-lookup"><span data-stu-id="a2681-345">To create an offline PWA app that interacts with authentication:</span></span>

* <span data-ttu-id="a2681-346">замените <xref:Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccountClaimsPrincipalFactory%601> фабрикой, которая хранит последнего пользователя, выполнившего вход, и использует сохраненного пользователя, когда приложение находится в автономном режиме;</span><span class="sxs-lookup"><span data-stu-id="a2681-346">Replace the <xref:Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccountClaimsPrincipalFactory%601> with a factory that stores the last signed-in user and uses the stored user when the app is offline.</span></span>
* <span data-ttu-id="a2681-347">поместите операции в очередь, пока приложение находится в автономном режиме, и примените их при переходе приложения в режим "в сети";</span><span class="sxs-lookup"><span data-stu-id="a2681-347">Queue operations while the app is offline and apply them when the app returns online.</span></span>
* <span data-ttu-id="a2681-348">во время выхода очистите сохраненного пользователя.</span><span class="sxs-lookup"><span data-stu-id="a2681-348">During sign out, clear the stored user.</span></span>

<span data-ttu-id="a2681-349">Описанные выше подходы демонстрируются в примере приложения [`CarChecker`](https://github.com/SteveSandersonMS/CarChecker).</span><span class="sxs-lookup"><span data-stu-id="a2681-349">The [`CarChecker`](https://github.com/SteveSandersonMS/CarChecker) sample app demonstrates the preceding approaches.</span></span> <span data-ttu-id="a2681-350">Ознакомьтесь со следующими частями приложения:</span><span class="sxs-lookup"><span data-stu-id="a2681-350">See the following parts of the app:</span></span>

* <span data-ttu-id="a2681-351">`OfflineAccountClaimsPrincipalFactory` (`Client/Data/OfflineAccountClaimsPrincipalFactory.cs`)</span><span class="sxs-lookup"><span data-stu-id="a2681-351">`OfflineAccountClaimsPrincipalFactory` (`Client/Data/OfflineAccountClaimsPrincipalFactory.cs`)</span></span>
* <span data-ttu-id="a2681-352">`LocalVehiclesStore` (`Client/Data/LocalVehiclesStore.cs`)</span><span class="sxs-lookup"><span data-stu-id="a2681-352">`LocalVehiclesStore` (`Client/Data/LocalVehiclesStore.cs`)</span></span>
* <span data-ttu-id="a2681-353">Компонент `LoginStatus` (`Client/Shared/LoginStatus.razor`)</span><span class="sxs-lookup"><span data-stu-id="a2681-353">`LoginStatus` component (`Client/Shared/LoginStatus.razor`)</span></span>

## <a name="additional-resources"></a><span data-ttu-id="a2681-354">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="a2681-354">Additional resources</span></span>

* [<span data-ttu-id="a2681-355">Скрипт PowerShell для устранения проблем целостности</span><span class="sxs-lookup"><span data-stu-id="a2681-355">Troubleshoot integrity PowerShell script</span></span>](xref:blazor/host-and-deploy/webassembly#troubleshoot-integrity-powershell-script)
* [<span data-ttu-id="a2681-356">Согласование независимо от источника для проверки подлинности для SignalR</span><span class="sxs-lookup"><span data-stu-id="a2681-356">SignalR cross-origin negotiation for authentication</span></span>](xref:blazor/fundamentals/additional-scenarios#signalr-cross-origin-negotiation-for-authentication)
