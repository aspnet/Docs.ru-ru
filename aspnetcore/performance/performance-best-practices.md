---
title: Рекомендации по повышению производительности ASP.NET Core
author: mjrousos
description: Советы по повышению производительности ASP.NET Core приложений и устранению распространенных проблем с производительностью.
monikerRange: '>= aspnetcore-2.1'
ms.author: riande
ms.date: 04/06/2020
no-loc:
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/performance-best-practices
ms.openlocfilehash: 01575ec87d2d346da7367523ca5e257d53de4983
ms.sourcegitcommit: 24106b7ffffc9fff410a679863e28aeb2bbe5b7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2020
ms.locfileid: "90722622"
---
# <a name="aspnet-core-performance-best-practices"></a>Рекомендации по повышению производительности ASP.NET Core

Автор: [Майк Роусос (Mike Rousos)](https://github.com/mjrousos)

В этой статье приводятся рекомендации по обеспечению оптимальной производительности с помощью ASP.NET Core.

## <a name="cache-aggressively"></a>Агрессивный кэш

Кэширование рассматривается в нескольких частях этого документа. Для получения дополнительной информации см. <xref:performance/caching/response>.

## <a name="understand-hot-code-paths"></a>Общие сведения о путях к горячему коду

В этом документе путь к *горячему коду* определяется как часто называемый путь к коду и где возникает большая часть времени выполнения. Пути с горячим кодом обычно ограничивают масштаб и производительность приложения и обсуждаются в нескольких частях этого документа.

## <a name="avoid-blocking-calls"></a>Избегайте блокирующих вызовов

ASP.NET Core приложения предназначены для одновременной обработки нескольких запросов. Асинхронные интерфейсы API позволяют небольшому пулу потоков работать с тысячами одновременных запросов, не дожидаясь блокировки вызовов. Вместо ожидания завершения длительной синхронной задачи поток может работать с другим запросом.

Распространенная проблема производительности в ASP.NET Core приложениях — блокировка вызовов, которые могут быть асинхронными. Многие синхронные блокирующие вызовы ведут к нехватке [пула потоков](/archive/blogs/vancem/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall) и снижению времени отклика.

**Не выполнять**:

* Блокировать асинхронное выполнение путем вызова [Task. Wait](/dotnet/api/system.threading.tasks.task.wait) или [Task. Result](/dotnet/api/system.threading.tasks.task-1.result).
* Получение блокировок в общих путях кода. ASP.NET Core приложения являются наиболее производительными при разработке архитектуры для параллельного выполнения кода.
* Вызовите [Task. Run](/dotnet/api/system.threading.tasks.task.run) и немедленно ожидайте ее. ASP.NET Core уже выполняет код приложения в обычных потоках пула потоков, поэтому вызов задачи. выполнение приведет только к ненужному планированию пула потоков. Даже если запланированный код блокирует поток, Task. Run не препятствует этому.

**Выполните**следующие действия.

* Сделайте [неактивные пути к коду](#understand-hot-code-paths) асинхронными.
* Асинхронно вызывайте API доступа к данным, ввода-вывода и длительные операции, если доступен асинхронный API. **Не** используйте [Task. Run](/dotnet/api/system.threading.tasks.task.run) , чтобы сделать синхронный API асинхронным.
* Сделайте действия контроллера или Razor страницы асинхронными. Весь стек вызовов является асинхронным, чтобы воспользоваться преимуществами шаблонов [async/await](/dotnet/csharp/programming-guide/concepts/async/) .

Профилировщик, например [PerfView](https://github.com/Microsoft/perfview), можно использовать для поиска потоков, часто добавляемых в [пул потоков](/windows/desktop/procthread/thread-pools). `Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start`Событие указывает поток, добавленный в пул потоков. <!--  For more information, see [async guidance docs](TBD-Link_To_Davifowl_Doc)  -->

## <a name="return-ienumerablet-or-iasyncenumerablet"></a>Возврат IEnumerable \<T> или иасинценумерабле\<T>

Возврат `IEnumerable<T>` из действия приводит к синхронной итерации коллекции с помощью сериализатора. В результате вызовы блокируются, что может стать причиной перегрузки пула потоков. Чтобы избежать синхронного перечисления, используйте `ToListAsync` перед возвратом перечислимого.

Начиная с ASP.NET Core 3,0, `IAsyncEnumerable<T>` можно использовать в качестве альтернативы для `IEnumerable<T>` перечисления в асинхронном режиме. Дополнительные сведения см. в разделе [типы возвращаемых данных действий контроллера](xref:web-api/action-return-types#return-ienumerablet-or-iasyncenumerablet).

## <a name="minimize-large-object-allocations"></a>Сведение к минимальному выделению больших объектов

[Сборщик мусора .NET Core](/dotnet/standard/garbage-collection/) управляет выделением и освобождением памяти автоматически в ASP.NET Core приложениях. Автоматическая сборка мусора обычно означает, что разработчикам не нужно беспокоиться о том, как или когда освобождается память. Тем не менее очистка объектов, на которые нет ссылок, занимает время ЦП, поэтому разработчики должны максимально сокращать выделение объектов в [путях горячего кода](#understand-hot-code-paths). Сборка мусора особенно затратна на большие объекты (> 85 КБайт). Большие объекты хранятся в [куче больших объектов](/dotnet/standard/garbage-collection/large-object-heap) и для очистки требуется полная сборка мусора (поколение 2). В отличие от коллекций поколений 0 и поколения 1, сборка поколения 2 требует временной приостановки выполнения приложения. Частое выделение и освобождение больших объектов могут привести к нестабильной производительности.

Рекомендации

* **Рассмотрите возможность** кэширования больших объектов, которые часто используются. Кэширование больших объектов предотвращает дорогостоящее выделение памяти.
* **Сделайте** буферы пула с помощью [аррайпул \<T> ](/dotnet/api/system.buffers.arraypool-1) для хранения больших массивов.
* **Не** выделяйте большое количество кратковременных больших объектов в [пути горячего кода](#understand-hot-code-paths).

Проблемы с памятью, например предшествующие, можно диагностировать путем просмотра статистики сборщика мусора (GC) в [PerfView](https://github.com/Microsoft/perfview) и изучения:

* Время остановки сборки мусора.
* Процент времени процессора, затраченный на сборку мусора.
* Количество сборок мусора, которые являются поколением 0, 1 и 2.

Дополнительные сведения см. в разделе [сбор мусора и производительность](/dotnet/standard/garbage-collection/performance).

## <a name="optimize-data-access-and-io"></a>Оптимизация доступа к данным и ввода-вывода

Взаимодействие с хранилищем данных и другими удаленными службами часто является наиболее медленной частью ASP.NET Core приложения. Эффективное чтение и запись данных крайне важно для обеспечения высокой производительности.

Рекомендации

* **Вызывайте все** API доступа к данным в асинхронном режиме.
* **Не** извлекать больше данных, чем требуется. Напишите запросы, возвращающие только те данные, которые необходимы для текущего HTTP-запроса.
* **Рассмотрите возможность** кэширования часто используемых данных, полученных из базы данных или удаленной службы, если это приемлемо для более неактуальных данных. В зависимости от сценария используйте [MemoryCache](xref:performance/caching/memory) или [DistributedCache](xref:performance/caching/distributed). Для получения дополнительной информации см. <xref:performance/caching/response>.
* **Сократите** круговые обходов сети. Целью является получение необходимых данных в одном вызове, а не в нескольких вызовах.
* **Не** используйте [запросы без отслеживания](/ef/core/querying/tracking#no-tracking-queries) в Entity Framework Core при доступе к данным в целях только для чтения. EF Core могут более эффективно возвращать результаты запросов без отслеживания.
* **Выполните** фильтрацию и агрегирование запросов LINQ (например, с помощью `.Where` `.Select` инструкций, или `.Sum` ), чтобы фильтрация выполнялась базой данных.
* **Учтите,** что EF Core разрешает некоторые операторы запросов на клиенте, что может привести к неэффективному выполнению запроса. Дополнительные сведения см. в статье [проблемы с производительностью оценки клиента](/ef/core/querying/client-eval#client-evaluation-performance-issues).
* **Не** Используйте проекции запросов к коллекциям, что может привести к выполнению запросов SQL N + 1. Дополнительные сведения см. в разделе [Оптимизация коррелированных вложенных запросов](/ef/core/what-is-new/ef-core-2.1#optimization-of-correlated-subqueries).

Методы, которые могут повысить производительность в крупномасштабных приложениях, см. в статье [Высокая производительность](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries) .

* [Создание пулов DbContext](/ef/core/what-is-new/ef-core-2.0#dbcontext-pooling)
* [Явным образом скомпилированные запросы](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries)

Мы рекомендуем оценить влияние предыдущих высокопроизводительных подходов перед фиксацией базы кода. Дополнительная сложность скомпилированных запросов может не отнять повышение производительности.

Проблемы запросов можно обнаружить, просмотрев время, затраченное на доступ к данным с помощью [Application Insights](/azure/application-insights/app-insights-overview) или с помощью средств профилирования. В большинстве баз данных также доступна статистика, касающаяся часто выполняемых запросов.

## <a name="pool-http-connections-with-httpclientfactory"></a>HTTP-соединения пула с Хттпклиентфактори

Хотя [HttpClient](/dotnet/api/system.net.http.httpclient) реализует `IDisposable` интерфейс, он предназначен для повторного использования. Закрытые `HttpClient` экземпляры оставляют сокеты открытыми в `TIME_WAIT` состоянии в течение короткого периода времени. Если часто используется путь кода, который создает и уничтожает `HttpClient` объекты, приложение может вычерпать доступные сокеты. [Хттпклиентфактори](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) был представлен в ASP.NET Core 2,1 в качестве решения этой проблемы. Он обрабатывает подключения по протоколу HTTP для оптимизации производительности и надежности.

Рекомендации

* **Не** Создавайте и удаляйте `HttpClient` экземпляры напрямую.
* **Используйте** [хттпклиентфактори](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) для получения `HttpClient` экземпляров. Дополнительные сведения см. [в статье Использование хттпклиентфактори для реализации устойчивых HTTP-запросов](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests).

## <a name="keep-common-code-paths-fast"></a>Быстрое отслеживание общих путей кода

Необходимо, чтобы весь код был быстрым. Часто называемые путями кода наиболее важны для оптимизации. Сюда входит следующее.

* Компоненты по промежуточного слоя в конвейере обработки запросов приложения, особенно по промежуточного слоя выполняются на раннем этапе конвейера. Эти компоненты сильно влияют на производительность.
* Код, который выполняется для каждого запроса или несколько раз для каждого запроса. Например, пользовательское ведение журнала, обработчики авторизации или инициализацию временных служб.

Рекомендации

* **Не** используйте пользовательские компоненты промежуточного слоя с долго выполняющимися задачами.
* **Используйте средства** профилирования производительности, такие как [Visual Studio средства диагностики](/visualstudio/profiling/profiling-feature-tour) или [PerfView](https://github.com/Microsoft/perfview)), для указания [путей использования горячих кодов](#understand-hot-code-paths).

## <a name="complete-long-running-tasks-outside-of-http-requests"></a>Выполнение длительных задач за пределами HTTP-запросов

Большинство запросов к ASP.NET Core приложению могут обрабатываться контроллером или моделью страницы, вызывающими необходимые службы и возвращающими ответ HTTP. Для некоторых запросов, в которых задействованы длительные задачи, лучше сделать весь процесс "запрос-ответ" асинхронным.

Рекомендации

* **Не** дожидаться завершения длительных задач в рамках обычной обработки HTTP-запросов.
* **Рассмотрите возможность** обработки долго выполняющихся запросов с помощью [фоновых служб](xref:fundamentals/host/hosted-services) или вне процесса с помощью [функции Azure](/azure/azure-functions/). Завершение работы вне процесса особенно полезно для ресурсоемких задач.
* **Do** [SignalR](xref:signalr/introduction) Для асинхронной связи с клиентами используйте параметры связи в режиме реального времени, например.

## <a name="minify-client-assets"></a>Ресурсы клиента уменьшение

ASP.NET Core приложения с комплексными внешними интерфейсами часто обслуживают множество файлов JavaScript, CSS или изображений. Производительность запросов начальной загрузки можно улучшить следующим образом.

* Объединение, объединяющее несколько файлов в один.
* Минификация, что сокращает размер файлов, удаляя пробелы и комментарии.

Рекомендации

* **Используйте** [встроенную поддержку](xref:client-side/bundling-and-minification) ASP.NET Core для объединения и Минификация клиентских ресурсов.
* **Ознакомьтесь с** другими сторонними инструментами, такими как веб- [пакет](https://webpack.js.org/), для комплексного управления клиентскими ресурсами.

## <a name="compress-responses"></a>Сжатие ответов

 Уменьшение размера ответа обычно значительно увеличивает скорость реагирования приложения. Одним из способов уменьшения размера полезных данных является сжатие ответов приложения. Дополнительные сведения см. в разделе [сжатие ответов](xref:performance/response-compression).

## <a name="use-the-latest-aspnet-core-release"></a>Использование последней версии ASP.NET Core

Каждый новый выпуск ASP.NET Core включает улучшения производительности. Оптимизация в .NET Core и ASP.NET Core означает, что более новые версии обычно более эффективны старые версии. Например, в .NET Core 2,1 добавлена поддержка скомпилированных регулярных выражений и выиграли [из \<T> span](/archive/msdn-magazine/2018/january/csharp-all-about-span-exploring-a-new-net-mainstay). В ASP.NET Core 2,2 добавлена поддержка HTTP/2. [ASP.NET Core 3,0 добавляет множество улучшений](xref:aspnetcore-3.0) , которые уменьшают использование памяти и увеличивают пропускную способность. Если производительность является приоритетной, рассмотрите возможность обновления до текущей версии ASP.NET Core.

## <a name="minimize-exceptions"></a>Уменьшение числа исключений

Исключения должны быть редкими. Создание и перехват исключений происходит очень долго относительно других шаблонов потока кода. Поэтому исключения не должны использоваться для управления нормальным выполнением программы.

Рекомендации

* **Не** используйте генерацию или перехват исключений в качестве средства обычного потока программы, особенно в [путях горячего кода](#understand-hot-code-paths).
* **Включите в** приложение логику для обнаружения и обработки условий, вызывающих исключение.
* **Вызывайте или** перехватите исключения для необычных или непредвиденных условий.

Средства диагностики приложений, такие как Application Insights, могут помочь в определении распространенных исключений в приложении, которое может повлиять на производительность.

## <a name="performance-and-reliability"></a>Производительность и надежность

Следующие разделы содержат советы по повышению производительности и известным проблемам надежности и решениям.

## <a name="avoid-synchronous-read-or-write-on-httprequesthttpresponse-body"></a>Избегайте синхронного чтения или записи в тексте HttpRequest/HttpResponse

Все операции ввода-вывода в ASP.NET Core являются асинхронными. Серверы реализуют `Stream` интерфейс, который имеет как синхронные, так и асинхронные перегрузки. Асинхронные объекты должны быть предпочтительнее, чтобы избежать блокирования потоков пула потоков. Блокировка потоков может привести к нехватке пула потоков.

Не Выменяйте **это:** В следующем примере используется <xref:System.IO.StreamReader.ReadToEnd*> . Он блокирует текущий поток для ожидания результата. Это пример [синхронизации через Async](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
).

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet1)]

В приведенном выше коде `Get` синхронно считывает весь текст HTTP-запроса в память. Если клиент медленно отправляется, приложение выполняет синхронизацию асинхронно. Приложение выполняет синхронизацию асинхронно, так как Kestrel **не поддерживает** синхронные операции чтения.

**Выполните следующие действия.** В следующем примере используется <xref:System.IO.StreamReader.ReadToEndAsync*> и не блокируется поток при чтении.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet2)]

Приведенный выше код асинхронно считывает весь текст HTTP-запроса в память.

> [!WARNING]
> Если запрос имеет большой размер, чтение всего текста HTTP-запроса в память может привести к нехватке памяти. Сбой может привести к отказу в обслуживании.  Дополнительные сведения см. в разделе [избежание считывания текста большого запроса или тела ответа в память](#arlb) в этом документе.

**Выполните следующие действия.** Следующий пример полностью асинхронно использует текст запроса без буферизации:

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet3)]

Приведенный выше код асинхронно десериализует текст запроса в объект C#.

## <a name="prefer-readformasync-over-requestform"></a>Предпочитать Реадформасинк по запросу. Form

Используйте `HttpContext.Request.ReadFormAsync` вместо `HttpContext.Request.Form`.
`HttpContext.Request.Form` может быть безопасно прочитано только со следующими условиями:

* Форма была считана путем вызова функции `ReadFormAsync` и
* Кэшированное значение формы считывается с помощью `HttpContext.Request.Form`

Не Выменяйте **это:** В следующем примере используется `HttpContext.Request.Form` .  `HttpContext.Request.Form` использует [синхронизацию асинхронно](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
) и может привести к нехватке пула потоков.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet1)]

**Выполните следующие действия.** В следующем примере метод используется `HttpContext.Request.ReadFormAsync` для асинхронного чтения текста формы.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet2)]

<a name="arlb"></a>

## <a name="avoid-reading-large-request-bodies-or-response-bodies-into-memory"></a>Избегайте считывания текста крупного запроса или тела ответа в память

В .NET каждое выделение объектов, превышающее 85 КБ, заканчивается в куче больших объектов ([LOH](https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/)). Большие объекты являются ресурсоемкими двумя способами:

* Стоимость выделения высока, так как память для вновь выделенного большого объекта должна быть сброшена. Среда CLR гарантирует, что память для всех вновь выделяемых объектов будет сброшена.
* LOH собирается вместе с остальной частью кучи. Для LOH требуется полная сборка [мусора](/dotnet/standard/garbage-collection/fundamentals) или [коллекция Gen2](/dotnet/standard/garbage-collection/fundamentals#generations).

Эта [запись блога](https://adamsitnik.com/Array-Pool/#the-problem) кратко описывает проблему:

> При выделении большого объекта он помечается как объект Gen 2. Не Gen 0 как для небольших объектов. Последствия в том, что если в LOH исчерпана память, сборщик мусора очищает всю управляемую кучу, а не только LOH. Он очищает Gen 0, Gen 1 и Gen 2, включая LOH. Это называется полной сборкой мусора и является наиболее длительным сбором мусора. Для многих приложений это может быть приемлемым. Но определенно не для высокопроизводительных веб-серверов, где несколько больших буферов памяти требуются для обработки среднего веб-запроса (чтение из сокета, распаковка, декодирование JSON & больше).

Простое хранение большого запроса или текста ответа в одном `byte[]` или `string` :

* Может привести к быстрому запуску пространства в LOH.
* Может вызвать проблемы с производительностью приложения из-за выполнения полных GC.

## <a name="working-with-a-synchronous-data-processing-api"></a>Работа с синхронным интерфейсом API обработки данных

При использовании сериализатора или отмены сериализатора, поддерживающего только синхронные операции чтения и записи (например,  [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)):

* Асинхронная буферизация данных в память перед их передачей в сериализатор/de-сериализатор.

> [!WARNING]
> Если запрос большой, это может привести к нехватке памяти («нехватки»). Сбой может привести к отказу в обслуживании.  Дополнительные сведения см. в разделе [избежание считывания текста большого запроса или тела ответа в память](#arlb) в этом документе.

ASP.NET Core 3,0 используется по <xref:System.Text.Json> умолчанию для СЕРИАЛИЗАЦИИ JSON. <xref:System.Text.Json>:

* асинхронно считывает и записывает JSON;
* оптимизирован для текста UTF-8;
* предоставляет более высокую производительность, чем `Newtonsoft.Json`.

## <a name="do-not-store-ihttpcontextaccessorhttpcontext-in-a-field"></a>Не хранить Ихттпконтекстакцессор. HttpContext в поле

[Ихттпконтекстакцессор. HttpContext](xref:Microsoft.AspNetCore.Http.IHttpContextAccessor.HttpContext) возвращает `HttpContext` Активный запрос при доступе из потока запроса. `IHttpContextAccessor.HttpContext` **Не** должен храниться в поле или переменной.

Не Выменяйте **это:** В следующем примере объект сохраняется `HttpContext` в поле, а затем попытается его использовать позже.

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet1)]

Приведенный выше код часто захватывает значение null или неверно `HttpContext` в конструкторе.

**Выполните следующие действия.** Следующий пример:

* Сохраняет <xref:Microsoft.AspNetCore.Http.IHttpContextAccessor> в поле.
* Использует `HttpContext` поле в нужное время и проверяет наличие `null` .

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet2)]

## <a name="do-not-access-httpcontext-from-multiple-threads"></a>Не обращаться к HttpContext из нескольких потоков

`HttpContext`*не* является потокобезопасным. Доступ `HttpContext` из нескольких потоков в параллельном режиме может привести к неопределенному поведению, такому как зависание, сбои и повреждение данных.

Не Выменяйте **это:** В следующем примере выполняется три параллельных запроса и записывается путь к входящему запросу до и после исходящего HTTP-запроса. Доступ к пути запроса осуществляется из нескольких потоков, которые могут быть параллельными.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet1&highlight=25,28)]

**Выполните следующие действия.** В следующем примере все данные из входящего запроса копируются перед выполнением трех параллельных запросов.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet2&highlight=6,8,22,28)]

## <a name="do-not-use-the-httpcontext-after-the-request-is-complete"></a>Не используйте HttpContext после завершения запроса

`HttpContext` допустимо только при условии, что в конвейере ASP.NET Core имеется активный HTTP-запрос. Весь конвейер ASP.NET Core является асинхронной цепочкой делегатов, выполняющих каждый запрос. После `Task` завершения возврата из этой цепочки `HttpContext` перезапускается.

Не Выменяйте **это:** В следующем примере используется `async void` , после чего HTTP-запрос завершается при `await` достижении первого.

* Это **всегда** является неправильной практикой в ASP.NET Core приложениях.
* Обращается к компоненту `HttpResponse` после завершения HTTP-запроса.
* Завершается сбоем процесса.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncBadVoidController.cs?name=snippet1)]

**Выполните следующие действия.** В следующем примере возвращается `Task` к платформе, поэтому HTTP-запрос не завершается до завершения действия.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncSecondController.cs?name=snippet1)]

## <a name="do-not-capture-the-httpcontext-in-background-threads"></a>Не захватывать HttpContext в фоновых потоках

Не Выменяйте **это:** В следующем примере показано, как захватывается замыкание `HttpContext` из `Controller` Свойства. Это неплохая практика, поскольку рабочий элемент может:

* Выполнение за пределами области запроса.
* Попытка прочитать ошибку `HttpContext` .

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet1)]

**Выполните следующие действия.** Следующий пример:

* Копирует данные, необходимые в фоновой задаче, во время запроса.
* Не ссылается на что-либо из контроллера.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet2)]

Фоновые задачи должны быть реализованы как размещенные службы. Дополнительные сведения см. в статье [Background tasks with hosted services in ASP.NET Core](xref:fundamentals/host/hosted-services) (Фоновые задачи с размещенными службами в ASP.NET Core).

## <a name="do-not-capture-services-injected-into-the-controllers-on-background-threads"></a>Не захватывать службы, внедренные в контроллеры в фоновых потоках

Не Выменяйте **это:** В следующем примере показано, как захватывается замыкание `DbContext` из `Controller` параметра Action. Это неплохой подход.  Рабочий элемент может выполняться вне области запроса. `ContosoDbContext`Область ограничена запросом, что приводит к возникновению `ObjectDisposedException` .

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet1)]

**Выполните следующие действия.** Следующий пример:

* Внедряет объект, <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory> чтобы создать область в фоновом рабочем элементе. `IServiceScopeFactory` является Singleton-классом.
* Создает новую область внедрения зависимостей в фоновом потоке.
* Не ссылается на что-либо из контроллера.
* Не захватывает `ContosoDbContext` из входящего запроса.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2)]

Выделенный ниже код:

* Создает область в течение времени существования фоновой операции и разрешает службы из нее.
* Использует `ContosoDbContext` из правильной области.

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2&highlight=9-16)]

## <a name="do-not-modify-the-status-code-or-headers-after-the-response-body-has-started"></a>Не изменяйте код состояния или заголовки после начала текста ответа

ASP.NET Core не замещает текст HTTP-ответа. При первом написании ответа:

* Заголовки отправляются клиенту вместе с этим фрагментом текста.
* Больше нельзя изменять заголовки ответа.

Не Выменяйте **это:** Следующий код пытается добавить заголовки ответа после того, как ответ уже запущен:

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet1)]

В приведенном выше коде `context.Response.Headers["test"] = "test value";` вызовет исключение, если в `next()` ответ записывается.

**Выполните следующие действия.** В следующем примере проверяется, начался ли HTTP-ответ перед изменением заголовков.

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet2)]

**Выполните следующие действия.** В следующем примере используется `HttpResponse.OnStarting` для установки заголовков перед тем, как заголовки ответа сбрасываются на клиент.

Проверка того, что ответ не запущен, позволяет регистрировать обратный вызов, который будет вызываться непосредственно перед заголовком ответа. Проверяется, не начался ли ответ:

* Предоставляет возможность добавлять или переопределять заголовки по времени.
* Не требует знания следующего по промежуточного слоя в конвейере.

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet3)]

## <a name="do-not-call-next-if-you-have-already-started-writing-to-the-response-body"></a>Не вызывайте Next (), если вы уже начали записывать в текст ответа.

Компоненты должны вызываться, только если они могут обрабатывать ответ и управлять им.

## <a name="use-in-process-hosting-with-iis"></a>Использование внутрипроцессного размещения с IIS

При внутрипроцессном размещении приложение ASP.NET Core выполняется в том же процессе, что и рабочий процесс IIS. Внутрипроцессный процесс обеспечивает повышенную производительность при наведении вне процесса, так как запросы не передаются через адаптер замыкания на себя. Адаптер замыкания на себя — это сетевой интерфейс, который возвращает исходящий сетевой трафик обратно на тот же компьютер. IIS обрабатывает управление процессом с помощью [службы активации процессов Windows (WAS)](/iis/manage/provisioning-and-managing-iis/features-of-the-windows-process-activation-service-was).

По умолчанию в проектах используется модель внутрипроцессного размещения в ASP.NET Core 3,0 и более поздних версиях.

Дополнительные сведения см. [в разделе Host ASP.NET Core в Windows со службами IIS](xref:host-and-deploy/iis/index) .