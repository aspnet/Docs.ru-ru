---
title: Вопросы безопасности в ASP.NET Core SignalR
author: bradygaster
description: Узнайте, как использовать проверку подлинности и авторизацию в ASP.NET Core SignalR .
monikerRange: '>= aspnetcore-2.1'
ms.author: anurse
ms.custom: mvc
ms.date: 01/16/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: signalr/security
ms.openlocfilehash: 5ecbf07b1527e9c68443870f7fce77adc29a5416
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2020
ms.locfileid: "93050840"
---
# <a name="security-considerations-in-aspnet-core-no-locsignalr"></a>Вопросы безопасности в ASP.NET Core SignalR

[Эндрю Стантон-медперсонала](https://twitter.com/anurse)

В этой статье приводятся сведения о защите SignalR .

## <a name="cross-origin-resource-sharing"></a>Предоставление общего доступа к ресурсам независимо от источника

[Общий доступ к ресурсам между источниками (CORS)](https://www.w3.org/TR/cors/) можно использовать, чтобы разрешить подключения между источниками SignalR в браузере. Если код JavaScript размещается в другом домене из SignalR приложения, необходимо включить по [промежуточного слоя CORS](xref:security/cors) , чтобы разрешить JavaScript подключаться к SignalR приложению. Разрешать запросы между источниками только из доменов, которым вы доверяете или контролируете. Пример:

* Ваш сайт размещен на `http://www.example.com`
* Ваше SignalR приложение размещено на `http://signalr.example.com`

CORS следует настроить в приложении, SignalR чтобы разрешить только источник `www.example.com` .

Дополнительные сведения о настройке CORS см. в разделе [Включение запросов между источниками (CORS)](xref:security/cors). SignalR**требуются** следующие политики CORS:

* Разрешить конкретные ожидаемые источники. Разрешение любого источника возможно, но **не** является безопасным или рекомендуемым.
* Методы HTTP `GET` и `POST` должны быть разрешены.
* Учетные данные должны быть разрешены для cookie правильной работы прикрепленных сеансов. Они должны быть включены, даже если проверка подлинности не используется.

::: moniker range=">= aspnetcore-5.0"

Однако в 5,0 мы предоставили в клиенте TypeScript возможность не использовать учетные данные.
Параметр не использовать учетные данные следует использовать только в том случае, если известно 100%, что учетные данные, такие как Cookie s, не требуются в приложении ( cookie они используются службой приложений Azure при использовании нескольких серверов для работы с закрепленными сеансами).

::: moniker-end

Например, следующая политика CORS позволяет SignalR клиенту, размещенному в браузере, `https://example.com` получать доступ к SignalR приложению, размещенному на `https://signalr.example.com` :

::: moniker range=">= aspnetcore-3.0"

```csharp
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    // ... other middleware ...

    // Make sure the CORS middleware is ahead of SignalR.
    app.UseCors(builder =>
    {
        builder.WithOrigins("https://example.com")
            .AllowAnyHeader()
            .WithMethods("GET", "POST")
            .AllowCredentials();
    });

    // ... other middleware ...
    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chathub");
    });

    // ... other middleware ...
}
```

::: moniker-end

::: moniker range="<= aspnetcore-2.2"

[!code-csharp[Main](security/sample/Startup.cs?name=snippet1)]

::: moniker-end

## <a name="websocket-origin-restriction"></a>Ограничение источника WebSocket

::: moniker range=">= aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Ограничение [по источнику](xref:fundamentals/websockets#websocket-origin-restriction)для соединений WebSocket.

::: moniker-end

::: moniker range="< aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Браузеры **не** поддерживают следующие задачи:

* выполнение предварительных запросов CORS;
* использование ограничений, указанных в заголовках `Access-Control`, при выполнении запросов WebSocket.

Однако браузеры отправляют заголовок `Origin` при выпуске запросов WebSocket. Приложения должны быть настроены для проверки этих заголовков, чтобы использовались только WebSocket из ожидаемых источников.

В ASP.NET Core 2,1 и более поздних версиях проверка заголовков может быть достигнута с помощью пользовательского промежуточного слоя, размещенного **до `UseSignalR` , и по промежуточного слоя** в `Configure` :

[!code-csharp[Main](security/sample/Startup.cs?name=snippet2)]

> [!NOTE]
> Заголовок `Origin` контролируется клиентом и, как и заголовок `Referer`, может быть подделан. Эти заголовки **не** следует использовать в качестве механизма проверки подлинности.

::: moniker-end

## <a name="connectionid"></a>ConnectionId

Предоставление доступа `ConnectionId` может привести к злонамеренному олицетворению, если SignalR версия сервера или клиента ASP.NET Core 2,2 или более ранняя. Если SignalR версия сервера и клиента ASP.NET Core 3,0 или более поздней версии, `ConnectionToken` вместо `ConnectionId` необходимо хранить секретный код. `ConnectionToken`Цель не предоставляется ни в одном API.  Может быть трудно убедиться, что старые SignalR клиенты не подключаются к серверу, поэтому, даже если SignalR серверная версия ASP.NET Core 3,0 или более поздней версии, она не `ConnectionId` должна быть предоставлена.

## <a name="access-token-logging"></a>Ведение журнала маркеров доступа

При использовании WebSockets или Server-Sent событий клиент браузера отправляет маркер доступа в строке запроса. Получение маркера доступа через строку запроса, как правило, безопасно с использованием стандартного `Authorization` заголовка. Всегда используйте протокол HTTPS, чтобы обеспечить безопасное сквозное подключение между клиентом и сервером. Многие веб-серверы заключают в журнал URL-адрес каждого запроса, включая строку запроса. Ведение журнала URL-адресов может регистрировать маркер доступа. ASP.NET Core записывает URL-адрес для каждого запроса по умолчанию, который будет включать строку запроса. Пример:

```
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:5000/chathub?access_token=1234
```

Если у вас есть вопросы о записи этих данных в журналы сервера, можно полностью отключить это ведение журнала, настроив `Microsoft.AspNetCore.Hosting` средство ведения журнала на `Warning` уровень или выше (эти сообщения записываются на `Info` уровне). Дополнительные сведения см. в разделе [Фильтрация журналов](xref:fundamentals/logging/index#log-filtering) для получения дополнительных сведений. Если вы по-прежнему хотите заносить в журнал определенные сведения о запросе, можно [написать по промежуточного слоя](xref:fundamentals/middleware/write) для записи нужных данных и отфильтровать `access_token` значение строки запроса (при наличии).

## <a name="exceptions"></a>Исключения

Сообщения об исключениях, как правило, считаются конфиденциальными данными, которые не следует раскрывать клиенту. По умолчанию SignalR не отправляет сведения об исключении, созданном методом концентратора клиенту. Вместо этого клиент получает общее сообщение с указанием произошедшей ошибки. Доставка сообщений об исключениях клиенту может быть переопределена (например, в разработке или тестировании) с помощью [енабледетаиледеррорс](xref:signalr/configuration#configure-server-options). Сообщения об исключениях не должны предоставляться клиенту в рабочих приложениях.

## <a name="buffer-management"></a>Управление буферами

SignalR использует буферы каждого подключения для управления входящими и исходящими сообщениями. По умолчанию SignalR ограничивает эти буферы до 32 КБ. Максимальное сообщение, которое клиент или сервер может отправить, — 32 КБ. Максимальный объем памяти, потребляемый соединением для сообщений, составляет 32 КБ. Если размер сообщений всегда меньше 32 КБ, можно уменьшить ограничение, которое:

* Запрещает клиенту отправить сообщение большего размера.
* Серверу не придется распределять большие буферы для приема сообщений.

Если размер сообщений превышает 32 КБ, можно увеличить это ограничение. Увеличение этого предела означает:

* Клиент может привести к выделению сервером больших буферов памяти.
* Выделение сервером больших буферов может сократить число одновременных подключений.

Существуют ограничения для входящих и исходящих сообщений. они могут быть настроены для объекта [хттпконнектиондиспатчероптионс](xref:signalr/configuration#configure-server-options) , настроенного в `MapHub` :

* `ApplicationMaxBufferSize` представляет максимальное число байтов от клиента, на котором находятся буферы сервера. Если клиент пытается отправить сообщение, размер которого превышает это ограничение, соединение может быть закрыто.
* `TransportMaxBufferSize` представляет максимальное число байтов, которое может быть отправлено сервером. Если сервер пытается отправить сообщение (включая возвращаемые значения из методов концентратора), превышающие это ограничение, будет создано исключение.

Установка ограничения `0` отключает ограничение. Удаление ограничения позволяет клиенту отправить сообщение любого размера. Вредоносные клиенты, отправляющие большие сообщения, могут вызвать чрезмерное выделение памяти. Чрезмерное использование памяти может значительно сократить количество одновременных подключений.
