---
title: Заголовки контекста в ASP.NET Core
author: rick-anderson
description: Сведения о реализации ASP.NET Core заголовков контекста защиты данных.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/implementation/context-headers
ms.openlocfilehash: 45463c9d96ad58e1721f7cb5c16912f783f646ed
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2020
ms.locfileid: "93051724"
---
# <a name="context-headers-in-aspnet-core"></a>Заголовки контекста в ASP.NET Core

<a name="data-protection-implementation-context-headers"></a>

## <a name="background-and-theory"></a>Фон и теория

В системе защиты данных "ключ" означает объект, который может предоставлять службы шифрования, прошедшие проверку подлинности. Каждый ключ идентифицируется с помощью уникального идентификатора (GUID) и включает в себя ИТ-алгоритмную информацию и энтропию. Предполагается, что каждый ключ имеет уникальную энтропию, но система не может их применить, и нам также нужно учитывать, что для разработчиков, которые могут изменить ключевое кольцо вручную, путем изменения алгоритма данных существующего ключа в кольце ключа. Для достижения требований безопасности в этих случаях система защиты данных имеет концепцию [криптографической гибкости](https://www.microsoft.com/research/publication/cryptographic-agility-and-its-relation-to-circular-encryption), которая позволяет безопасно использовать одно значение энтропии в нескольких алгоритмах шифрования.

Большинство систем, поддерживающих гибкость криптографии, делают это, включая некоторые идентифицирующие сведения о алгоритме в полезных данных. Как правило, этот идентификатор является хорошим кандидатом для этого. Однако одна из проблем, с которыми мы столкнулись, заключается в том, что существует несколько способов указать один и тот же алгоритм: "AES" (CNG), а управляемые классы AES, AesManaged, AesCryptoServiceProvider, AesCng и RijndaelManaged (заданные конкретные параметры) фактически одинаковы, и нам пришлось бы поддерживать сопоставление всех этих классов с правильным идентификатором OID. Если разработчик хочет предоставить пользовательский алгоритм (или даже другую реализацию AES!), ему пришлось бы сообщить нам свой идентификатор OID. Этот дополнительный шаг регистрации делает конфигурацию системы особенно ненужной.

При пошаговом выполнении мы решили, что мы разрешили проблему в неправильном направлении. OID сообщает, что представляет собой алгоритм, но на самом деле это не важно. Если необходимо безопасно использовать одно значение энтропии в двух разных алгоритмах, нет необходимости знать, что именно представляют собой алгоритмы. В действительности мы будем заниматься тем, как они ведут себя. Любой неназначенный симметричный алгоритм блочного шифра также является строго псевдослучайноеой перестановки (репликации паролей): исправьте входные данные (режим цепочки, последовательного режима, вектор инициализации, обычный текст) и вывод зашифрованного текста с перегруженной вероятностью будет отличаться от любого другого алгоритма симметричного блочного шифра, Аналогичным образом любая функция хэширования с любыми ключевыми ключами также является строгой функцией псевдослучайное (PRF), и при указании фиксированного входного набора его выходные данные будут совершенно отличаться от любых других хэш-функций с ключом.

Мы используем эту концепцию strong PRP и Прфс для создания заголовка контекста. Этот заголовок контекста, по сути, действует как стабильный отпечаток по сравнению с алгоритмами, используемыми для любой конкретной операции, и обеспечивает гибкость шифрования, необходимую системе защиты данных. Этот заголовок воспроизводится воспроизводимым образом и используется позже как часть [процесса наследования подраздела](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation). Существует два разных способа построения заголовка контекста в зависимости от режимов работы базовых алгоритмов.

## <a name="cbc-mode-encryption--hmac-authentication"></a>Шифрование в режиме CBC + проверка подлинности HMAC

<a name="data-protection-implementation-context-headers-cbc-components"></a>

Заголовок контекста состоит из следующих компонентов:

* [16 бит] Значение 00 00, которое является маркером, означающее "шифрование CBC + HMAC Authentication".

* [32 бит] Длина ключа (в байтах с обратным порядком байтов) для алгоритма симметричного блочного шифра.

* [32 бит] Размер блока (в байтах с обратным порядком байтов) для алгоритма симметричного блочного шифра.

* [32 бит] Длина ключа (в байтах с обратным порядком байтов) для алгоритма HMAC. (В настоящее время размер ключа всегда совпадает с размером дайджеста.)

* [32 бит] Размер дайджеста (в байтах с обратным порядком байтов) для алгоритма HMAC.

* `EncCBC(K_E, IV, "")`, который является выходным значением алгоритма симметричного блочного шифра, в котором используется входная пустая строка и где IV является нулевым вектором. Конструкция `K_E` описана ниже.

* `MAC(K_H, "")`, который является выходным результатом алгоритма HMAC по заданному входу пустой строки. Конструкция `K_H` описана ниже.

В идеале мы можем передать все нулевые векторы для `K_E` и `K_H` . Однако мы хотим избежать ситуации, когда базовый алгоритм проверяет наличие слабых ключей перед выполнением любых операций (особенно DES и 3DES), которые не могут использовать простой или повторяемый шаблон, такой как «все-ноль».

Вместо этого мы используем директиву NIST SP800-108 ПОДПРОГРАММ в режиме счетчика (см. директивы [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5,1) с нулевой длиной ключа, метки и контекста и HMACSHA512 в качестве базового PRF. Мы получаем `| K_E | + | K_H |` байты выходных данных, а затем разбивают результат на `K_E` и `K_H` сами. В математическом виде это представлено следующим образом.

`( K_E || K_H ) = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")`

### <a name="example-aes-192-cbc--hmacsha256"></a>Пример: AES-192-CBC + HMACSHA256

В качестве примера рассмотрим случай, когда алгоритм симметричного блочного шифра — AES-192-CBC, а алгоритм проверки — HMACSHA256. Система создаст заголовок контекста, выполнив следующие действия.

Сначала позвольте `( K_E || K_H ) = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")` , где и в соответствии `| K_E | = 192 bits` `| K_H | = 256 bits` с указанными алгоритмами. Это приводит к `K_E = 5BB6..21DD` и `K_H = A04A..00A9` в следующем примере:

```
5B B6 C9 83 13 78 22 1D 8E 10 73 CA CF 65 8E B0
61 62 42 71 CB 83 21 DD A0 4A 05 00 5B AB C0 A2
49 6F A5 61 E3 E2 49 87 AA 63 55 CD 74 0A DA C4
B7 92 3D BF 59 90 00 A9
```

Затем вычислите `Enc_CBC (K_E, IV, "")` данные для AES-192-CBC `IV = 0*` и `K_E` как описано выше.

`result := F474B1872B3B53E4721DE19C0841DB6F`

Далее, вычисление `MAC(K_H, "")` для HMACSHA256 было задано `K_H` как выше.

`result := D4791184B996092EE1202F36E8608FA8FBD98ABDFF5402F264B1D7211536220C`

В результате будет получен заголовок полного контекста ниже:

```
00 00 00 00 00 18 00 00 00 10 00 00 00 20 00 00
00 20 F4 74 B1 87 2B 3B 53 E4 72 1D E1 9C 08 41
DB 6F D4 79 11 84 B9 96 09 2E E1 20 2F 36 E8 60
8F A8 FB D9 8A BD FF 54 02 F2 64 B1 D7 21 15 36
22 0C
```

Этот заголовок контекста представляет собой отпечаток пары алгоритмов шифрования с проверкой подлинности (AES-192-CBC Encryption + HMACSHA256). Ниже перечислены компоненты, описанные [выше](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers-cbc-components) .

* маркер `(00 00)`

* Длина ключа блочного шифра `(00 00 00 18)`

* Размер блока блочного шифра `(00 00 00 10)`

* Длина ключа HMAC `(00 00 00 20)`

* Размер дайджеста HMAC `(00 00 00 20)`

* выходные данные блочного шифра репликации `(F4 74 - DB 6F)` и

* выходные данные HMAC "PRF" `(D4 79 - end)` .

> [!NOTE]
> Заголовок контекста проверки подлинности шифрования и HMAC в режиме CBC создается одинаково независимо от того, предоставляются ли реализации алгоритмов Windows CNG или управляемыми типами SymmetricAlgorithm и KeyedHashAlgorithm. Это позволяет приложениям, работающим в разных операционных системах, надежно создавать один и тот же заголовок контекста, даже несмотря на то, что реализации алгоритмов отличаются в разных ОС. (На практике KeyedHashAlgorithm не обязательно должен быть правильным HMAC. Это может быть любой тип хэш-алгоритма с ключом.)

### <a name="example-3des-192-cbc--hmacsha1"></a>Пример: 3DES-192-CBC + HMACSHA1

Сначала позвольте `( K_E || K_H ) = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")` , где и в соответствии `| K_E | = 192 bits` `| K_H | = 160 bits` с указанными алгоритмами. Это приводит к `K_E = A219..E2BB` и `K_H = DC4A..B464` в следующем примере:

```
A2 19 60 2F 83 A9 13 EA B0 61 3A 39 B8 A6 7E 22
61 D9 F8 6C 10 51 E2 BB DC 4A 00 D7 03 A2 48 3E
D1 F7 5A 34 EB 28 3E D7 D4 67 B4 64
```

Затем необходимо выполнить вычисление `Enc_CBC (K_E, IV, "")` для 3DES-192-CBC `IV = 0*` и `K_E` , как и выше.

`result := ABB100F81E53E10E`

Далее, вычисление `MAC(K_H, "")` для HMACSHA1 было задано `K_H` как выше.

`result := 76EB189B35CF03461DDF877CD9F4B1B4D63A7555`

При этом создается полный заголовок контекста, который является отпечатком пары алгоритмов шифрования с проверкой подлинности (3DES-192-CBC + HMACSHA1 Validation), как показано ниже:

```
00 00 00 00 00 18 00 00 00 08 00 00 00 14 00 00
00 14 AB B1 00 F8 1E 53 E1 0E 76 EB 18 9B 35 CF
03 46 1D DF 87 7C D9 F4 B1 B4 D6 3A 75 55
```

Компоненты разбивается на следующие:

* маркер `(00 00)`

* Длина ключа блочного шифра `(00 00 00 18)`

* Размер блока блочного шифра `(00 00 00 08)`

* Длина ключа HMAC `(00 00 00 14)`

* Размер дайджеста HMAC `(00 00 00 14)`

* выходные данные блочного шифра репликации `(AB B1 - E1 0E)` и

* выходные данные HMAC "PRF" `(76 EB - end)` .

## <a name="galoiscounter-mode-encryption--authentication"></a>Галоис/шифрование в режиме счетчика + аутентификация

Заголовок контекста состоит из следующих компонентов:

* [16 бит] Значение 00 01, которое является маркером "шифрование GCM + проверка подлинности".

* [32 бит] Длина ключа (в байтах с обратным порядком байтов) для алгоритма симметричного блочного шифра.

* [32 бит] Размер nonce (в байтах с обратным порядком байтов), используемый во время операций шифрования, прошедших проверку подлинности. (Для нашей системы это исправлено на nonce size = 96 бит.)

* [32 бит] Размер блока (в байтах с обратным порядком байтов) для алгоритма симметричного блочного шифра. (Для GCM это фиксировано в блоке размером = 128 бит.)

* [32 бит] Размер тега проверки подлинности (в байтах с обратным порядком байтов), созданный функцией шифрования с проверкой подлинности. (Для нашей системы это фиксировано по размеру тега = 128 бит.)

* [128 бит] Тег `Enc_GCM (K_E, nonce, "")` , который является выходным значением алгоритма симметричного блочного шифра, учитывая входную пустую строку и где nonce — это 96-разрядный вектор с нулевым значением.

`K_E` является производным, используя тот же механизм, что и в сценарии проверки подлинности шифрования CBC + HMAC. Тем не менее, так как здесь нет, то, по `K_H` сути `| K_H | = 0` , есть, и алгоритм сворачивается в приведенную ниже форму.

`K_E = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")`

### <a name="example-aes-256-gcm"></a>Пример: AES-256-GCM

Сначала позвольте `K_E = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")` , где `| K_E | = 256 bits` .

`K_E := 22BC6F1B171C08C4AE2F27444AF8FC8B3087A90006CAEA91FDCFB47C1B8733B8`

Затем вычислите тег проверки подлинности `Enc_GCM (K_E, nonce, "")` для AES-256-gcm в заданном `nonce = 096` и `K_E` приведенном выше виде.

`result := E7DCCE66DF855A323A6BB7BD7A59BE45`

В результате будет получен заголовок полного контекста ниже:

```
00 01 00 00 00 20 00 00 00 0C 00 00 00 10 00 00
00 10 E7 DC CE 66 DF 85 5A 32 3A 6B B7 BD 7A 59
BE 45
```

Компоненты разбивается на следующие:

* маркер `(00 01)`

* Длина ключа блочного шифра `(00 00 00 20)`

* Размер nonce `(00 00 00 0C)`

* Размер блока блочного шифра `(00 00 00 10)`

* Размер тега проверки подлинности `(00 00 00 10)` и

* Тег проверки подлинности для запуска блочного шифра `(E7 DC - end)` .
