---
title: Часть 8. Razor Pages с EF Core в ASP.NET Core — параллелизм
author: rick-anderson
description: Часть 8 серии руководств по Razor Pages и Entity Framework.
ms.author: riande
ms.custom: mvc
ms.date: 07/22/2019
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: data/ef-rp/concurrency
ms.openlocfilehash: 573a509041bfb34faf50a227c451824db03f92ee
ms.sourcegitcommit: 3593c4efa707edeaaceffbfa544f99f41fc62535
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/04/2021
ms.locfileid: "93053999"
---
# <a name="part-8-no-locrazor-pages-with-ef-core-in-aspnet-core---concurrency"></a>Часть 8. Razor Pages с EF Core в ASP.NET Core — параллелизм

Авторы: [Рик Андерсон](https://twitter.com/RickAndMSFT) (Rick Anderson), [Том Дайкстра](https://github.com/tdykstra) (Tom Dykstra) и [Йон П. Смит](https://twitter.com/thereformedprog) (Jon P Smith)

[!INCLUDE [about the series](../../includes/RP-EF/intro.md)]

::: moniker range=">= aspnetcore-3.0"

Это руководство описывает, как обрабатывать конфликты, когда несколько пользователей параллельно (одновременно) изменяют одну сущность.

## <a name="concurrency-conflicts"></a>Конфликты параллелизма

Конфликт параллелизма возникает в следующих условиях:

* Пользователь переходит на страницу редактирования для сущности.
* Другой пользователь обновляет ту же сущность до того, как изменение первого пользователя записывается в базу данных.

Если обнаружение параллелизма не включено, то пользователь, обновляющий базу данных последним, перезаписывает изменения другого пользователя. Если такой риск допустим, стоимость реализации параллелизма может перевесить его преимущества.

### <a name="pessimistic-concurrency-locking"></a>Пессимистичный параллелизм (блокировка)

Один из способов предотвращения конфликтов параллелизма — блокировка базы данных. Это называется пессимистичным параллелизмом. Прежде чем приложение считывает строку базы данных, которую планируется обновить, оно запрашивает блокировку. Когда строка блокируется для обновления, другие пользователи не могут заблокировать ее, пока первая блокировка не будет снята.

Управление блокировками имеет недостатки. Его может быть сложно реализовать, и оно может вызывать проблемы с производительностью по мере увеличения числа пользователей. В Entity Framework Core нет встроенной поддержки этой функции, и данное руководство не рассказывает, как ее реализовать.

### <a name="optimistic-concurrency"></a>Оптимистическая блокировка

Оптимистическая блокировка допускает появление конфликтов параллелизма, а затем обрабатывает их соответствующим образом. Например, Мария посещает страницу изменения кафедры и изменяет бюджет кафедры английской языка с 350 000,00 USD на 0,00 USD.

![Изменение бюджета на 0](concurrency/_static/change-budget30.png)

Прежде чем Мария нажимает кнопку **Save** (Сохранить), Дмитрий заходит на ту же страницу и изменяет значение в поле "Start Date" (Дата начала) с 9/1/2007 на 9/1/2013.

![Изменение начальной даты на 2013 г.](concurrency/_static/change-date30.png)

Сначала Мария нажимает кнопку **Save** (Сохранить) и видит, что ее изменение вступило в силу, так как в браузере отображается страница индекса с нулевым размером бюджета.

Дмитрий нажимает кнопку **Save** (Сохранить) на странице редактирования, где все еще отображается бюджет 350 000,00 USD. Дальнейший ход событий определяется порядком обработки конфликтов параллелизма.

* Вы можете отслеживать, для какого свойства пользователь изменил и обновил только соответствующие столбцы в базе данных.

  В этом сценарии никакие данные не теряются. Разные свойства были обновлены двумя пользователями. Когда какой-либо пользователь просмотрит кафедру английского языка в следующий раз, он увидит изменения, внесенные как Марией, так и Дмитрием. Этот способ обновления позволяет снизить количество конфликтов, способных привести к потере данных. Такой подход имеет ряд недостатков.
 
  * Он не позволяет избежать потери данных, если конкурирующие изменения вносятся для одного свойства.
  * Он не слишком хорошо подходит для веб-приложений, так как требует поддерживать значительный объем состояний, чтобы отслеживать все извлеченные и новые значения. Обслуживание большого объема состояний может негативно повлиять на производительность приложения.
  * Он может повысить сложность приложений по сравнению с обнаружением параллелизма для сущности.

* Вы можете позволить изменению Дмитрия перезаписать изменение Марии.

  Когда какой-либо пользователь просмотрит кафедру английского языка в следующий раз, он увидит дату 9/1/2013 и значение 350 000,00 USD. Такой подход называется *победой клиента* или *сохранением последнего внесенного изменения*. (Все значения из клиента имеют приоритет над данными в хранилище.) Если не писать код для обработки параллелизма, автоматически применяется победа клиента.

* Вы можете запретить обновление изменения Дмитрия в базе данных. Как правило приложение будет:

  * отображать сообщение об ошибке;
  * отображать текущее состояние данных;
  * разрешать пользователю повторно применять изменения.

  Это называется *победой хранилища*. (Значения в хранилище имеют приоритет над данными, передаваемыми клиентом.) В этом руководстве вы реализуете сценарий победы хранилища. Данный метод гарантирует, что никакие изменения не перезаписываются без оповещения пользователя.

## <a name="conflict-detection-in-ef-core"></a>Обнаружение конфликтов в EF Core

При обнаружении конфликтов EF Core создает исключения `DbConcurrencyException`. Модель данных необходимо настроить для обнаружения конфликтов. Ниже приведены варианты реализации обнаружения конфликтов.

* Настройте в EF Core включение исходных значений столбцов, настроенных как [токены параллелизма](/ef/core/modeling/concurrency), в предложение Where команд Update и Delete.

  При вызове `SaveChanges` предложение Where ищет исходные значения всех свойств, помеченных атрибутом <xref:System.ComponentModel.DataAnnotations.ConcurrencyCheckAttribute>. Инструкция UPDATE не найдет обновляемую строку, если какие-либо свойства токенов параллелизма изменились с момента первого чтения строки. EF Core интерпретирует это как конфликт параллелизма. Для таблиц базы данных со множеством столбцов этот подход может привести к очень большим предложениям Where и потребовать большого объема состояний. Поэтому в общем случае данный подход не рекомендуется, кроме того, он не применяется и в этом руководстве.

* Включите в таблицу базы данных столбец отслеживания, который позволяет определять, когда была изменена строка.

  В базе данных SQL Server типом данных для столбца отслеживания является `rowversion`. Значение `rowversion` является последовательным номером, увеличивающимся при каждом обновлении строки. В команде Update или Delete предложение Where содержит исходное значение столбца отслеживания (номер исходной версии строки). Если обновляемая строка была изменена другим пользователем, значение в столбце `rowversion` отличается от исходного. В этом случае инструкции Update или Delete не удается найти строку для обновления из-за предложения Where. Если нет строк, затронутых командой Update или Delete, EF Core создает исключение параллелизма.

## <a name="add-a-tracking-property"></a>Добавление свойства отслеживания

В *Models/Department.cs* добавьте свойство отслеживания RowVersion:

[!code-csharp[](intro/samples/cu30/Models/Department.cs?highlight=26,27)]

Именно атрибут <xref:System.ComponentModel.DataAnnotations.TimestampAttribute> определяет столбец как столбец отслеживания параллелизма. Другой способ задания свойства отслеживания — текучий API.

```csharp
modelBuilder.Entity<Department>()
  .Property<byte[]>("RowVersion")
  .IsRowVersion();
```

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

Для базы данных SQL Server атрибут `[Timestamp]` свойства сущности, определенного как массив байтов, делает следующее:

* приводит к тому, что столбец включается в предложения WHERE инструкций DELETE и UPDATE;
* задает тип [rowversion](/sql/t-sql/data-types/rowversion-transact-sql) для столбца в базе данных.

База данных формирует последовательный номер версии строки, увеличивающийся при каждом обновлении строки. В команде `Update` или `Delete` предложение `Where` включает в себя извлеченное значение версии строки. Если обновляемая строка изменились с момента получения:

* текущее значение версии строки не соответствует полученному значению;
* команда `Update` или `Delete` не находит строку, так как предложение `Where` ищет полученное значение версии строки;
* Возникает исключение `DbUpdateConcurrencyException`.

В следующем коде показана часть кода T-SQL, созданного EF Core при обновлении названия кафедры:

[!code-sql[](intro/samples/cu30snapshots/8-concurrency/sql.txt?highlight=2-3)]

Предыдущий выделенный код показывает предложение `WHERE`, содержащее `RowVersion`. Если база данных `RowVersion` не соответствует параметру `RowVersion` (`@p2`), строки не обновляются.

Следующий выделенный код показывает код T-SQL, который подтверждает, что была обновлена всего одна строка.

[!code-sql[](intro/samples/cu30snapshots/8-concurrency/sql.txt?highlight=4-6)]

[@@ROWCOUNT](/sql/t-sql/functions/rowcount-transact-sql) возвращает число строк, затронутых при выполнении последнего оператора. Если строки не обновляются, EF Core создает исключение `DbUpdateConcurrencyException`.

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

Для базы данных SQLite атрибут `[Timestamp]` свойства сущности, определенного как массив байтов, делает следующее:

* приводит к тому, что столбец включается в предложения WHERE инструкций DELETE и UPDATE;
* выполняет сопоставление с типом столбца больших двоичных объектов.

Триггеры базы данных обновляют столбец RowVersion новым случайным массивом байтов при каждом обновлении строки. В команде `Update` или `Delete` предложение `Where` включает в себя извлеченное значение столбца RowVersion. Если обновляемая строка изменились с момента получения:

* текущее значение версии строки не соответствует полученному значению;
* команда `Update` или `Delete` не находит строку, так как предложение `Where` ищет исходное значение версии строки;
* Возникает исключение `DbUpdateConcurrencyException`.

---

### <a name="update-the-database"></a>Обновление базы данных

Добавление свойства `RowVersion` изменяет модель данных, которая требует миграции.

Выполните построение проекта. 

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

* Выполните следующую команду в PMC:

  ```powershell
  Add-Migration RowVersion
  ```

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

* В терминале выполните следующую команду:

  ```dotnetcli
  dotnet ef migrations add RowVersion
  ```

---

Эта команда:

* Создает файл миграции *Migrations/{метка времени}_RowVersion.cs*.
* Изменяет файл *Migrations/SchoolContextModelSnapshot.cs*. Это изменение добавляет следующий выделенный код в метод `BuildModel`:

  [!code-csharp[](intro/samples/cu30/Migrations/SchoolContextModelSnapshot.cs?name=snippet_Department&highlight=15-17)]

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

* Выполните следующую команду в PMC:

  ```powershell
  Update-Database
  ```

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

* Откройте файл `Migrations/<timestamp>_RowVersion.cs` и добавьте в него выделенный код.

  [!code-csharp[](intro/samples/cu30/MigrationsSQLite/20190722151951_RowVersion.cs?highlight=16-42)]

  Предыдущий код:

  * Обновляет существующие строки случайными значениями больших двоичных объектов.
  * Добавляет триггеры базы данных, которые присваивают столбцу RowVersion случайное значение большого двоичного объекта при каждом обновлении строки.

* В терминале выполните следующую команду:

  ```dotnetcli
  dotnet ef database update
  ```

---

<a name="scaffold"></a>

## <a name="scaffold-department-pages"></a>Формирование шаблона страниц кафедр

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

* Следуйте инструкциям в разделе [Формирование шаблона для страниц Student](xref:data/ef-rp/intro#scaffold-student-pages), за исключением следующего:

* Создайте папку *Pages/Departments*.  
* Используйте класс модели `Department`.
  * Используйте существующий класс контекста вместо создания нового.

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

* Создайте папку *Pages/Departments*.

* Выполните приведенную ниже команду, чтобы сформировать шаблон для страниц кафедр.

  **В Windows:**

  ```dotnetcli
  dotnet aspnet-codegenerator razorpage -m Department -dc SchoolContext -udl -outDir Pages\Departments --referenceScriptLibraries
  ```

  **В Linux или macOS:**

  ```dotnetcli
  dotnet aspnet-codegenerator razorpage -m Department -dc SchoolContext -udl -outDir Pages/Departments --referenceScriptLibraries
  ```

---

Выполните построение проекта.

## <a name="update-the-index-page"></a>Обновление страницы индекса

Средство формирования шаблонов создало столбец `RowVersion` для страницы индекса, однако это поле не будет отображаться в рабочем приложении. В этом учебнике отображается последний байт `RowVersion` для демонстрации работы параллелизма. Этот последний байт необязательно является уникальным.

Обновите страницу *Pages\Departments\Index.cshtml*:

* Замените Index на Departments.
* Измените код, содержащий `RowVersion`, чтобы отображался только последний байт массива байтов.
* Замените FirstMidName на FullName.

В следующем примере кода показана обновленная страница:

[!code-cshtml[](intro/samples/cu30/Pages/Departments/Index.cshtml?highlight=5,8,29,48,51)]

## <a name="update-the-edit-page-model"></a>Обновление модели страницы "Edit" (Редактирование)

Измените *Pages\Departments\Edit.cshtml.cs*, используя следующий код:

[!code-csharp[](intro/samples/cu30/Pages/Departments/Edit.cshtml.cs?name=snippet_All)]

<xref:Microsoft.EntityFrameworkCore.ChangeTracking.PropertyEntry.OriginalValue> обновляется с помощью значения `rowVersion` из сущности при получении в методе `OnGet`. EF Core создает команду SQL UPDATE с предложением WHERE, содержащим исходное значение `RowVersion`. Если команда UPDATE не затрагивает никакие строки (нет строк, имеющих исходное значение `RowVersion`), возникает исключение `DbUpdateConcurrencyException`.

[!code-csharp[](intro/samples/cu30/Pages/Departments/Edit.cshtml.cs?name=snippet_RowVersion&highlight=17-18)]

В предыдущем выделенном коде:

* Значение в `Department.RowVersion` — это значение, которое имела сущность, когда она была изначально получена в запросе Get для страницы редактирования. Значение передается в метод `OnPost` посредством скрытого поля на странице Razor, на которой отображается редактируемая сущность. Значение скрытого поля копируется в `Department.RowVersion` связывателем модели.
* EF Core будет использовать в предложении Where значение `OriginalValue`. Перед выполнением выделенной строки кода `OriginalValue` имеет значение, которое было в базе данных при вызове `FirstOrDefaultAsync` в этом методе. Оно может отличаться от того, которое отображалось на странице редактирования.
* Выделенный код гарантирует, что EF Core использует исходное значение `RowVersion` из отображаемой сущности `Department` в предложении WHERE инструкции SQL UPDATE.

При возникновении ошибки параллелизма приведенный ниже выделенный код получает значения клиента (значения, переданные в этот метод) и значения из базы данных.

[!code-csharp[](intro/samples/cu30/Pages/Departments/Edit.cshtml.cs?name=snippet_TryUpdateModel&highlight=14,23)]

Следующий код добавляет пользовательское сообщение об ошибке для каждого столбца, у которого значения базы данных отличаются от переданных в `OnPostAsync`:

[!code-csharp[](intro/samples/cu30/Pages/Departments/Edit.cshtml.cs?name=snippet_Error)]

Приведенный ниже выделенный код задает для `RowVersion` новое значение, полученное из базы данных. Когда пользователь в следующий раз нажимает кнопку **Save** (Сохранить), перехватываются только те ошибки параллелизма, возникшие с момента последнего отображения страницы "Edit" (Редактирование).

[!code-csharp[](intro/samples/cu30/Pages/Departments/Edit.cshtml.cs?name=snippet_TryUpdateModel&highlight=28)]

Оператор `ModelState.Remove` является обязательным, так как `ModelState` имеет старое значение `RowVersion`. На странице Razor значение `ModelState` для поля имеет приоритет над значениями свойств модели, если они присутствуют вместе.

### <a name="update-the-edit-page"></a>Обновление страницы редактирования

Измените файл *Pages/Departments/Edit.cshtml*, используя следующий код:

[!code-cshtml[](intro/samples/cu30/Pages/Departments/Edit.cshtml?highlight=1,14,16-17,37-39)]

Предыдущий код:

* Изменяет директиву `page` с `@page` на `@page "{id:int}"`.
* Добавляет версию скрытых строк. Нужно добавить `RowVersion`, чтобы обратная передача привязывала значение.
* Отображает последний байт `RowVersion` в целях отладки.
* Заменяет `ViewData` на строго типизированный `InstructorNameSL`.

### <a name="test-concurrency-conflicts-with-the-edit-page"></a>Тестирование конфликтов параллелизма с использованием страницы "Edit" (Редактирование)

Откройте в браузере два экземпляра страницы "Edit" (Редактирование) для кафедры английского языка:

* Запустите приложение и выберите "Departments" (Кафедры).
* Щелкните правой кнопкой мыши гиперссылку **Edit** (Изменить) для кафедры английского языка и выберите пункт **Открыть на новой вкладке**.
* На первой вкладке щелкните гиперссылку **Edit** (Изменить) для кафедры английского языка.

На обеих вкладках браузера отображаются одинаковые сведения.

Измените имя на первой вкладке браузера и нажмите кнопку **Save** (Сохранить).

![Страница "Edit" (Редактирование) кафедры 1 после изменения](concurrency/_static/edit-after-change-130.png)

В браузере отображается страница индекса с измененным значением и обновленным индикатором rowVersion. Обратите внимание на обновленный индикатор rowVersion, он отображается при второй обратной передаче на другой вкладке.

Измените другое поле на второй вкладке браузера.

![Страница "Edit" (Редактирование) кафедры 2 после изменения](concurrency/_static/edit-after-change-230.png)

Нажмите кнопку **Сохранить**. Отображаются сообщения об ошибках для всех полей, которые не соответствуют значениям базы данных:

![Сообщение об ошибке для страницы "Edit" (Редактирование) кафедры](concurrency/_static/edit-error30.png)

В этом окне браузера не планировалось изменять поле "Name" (Имя). Скопируйте и вставьте текущее значение "Languages" (Языки) в поле "Name" (Имя). Выйдите из поля с помощью клавиши TAB. Проверка на стороне клиента удаляет сообщение об ошибке.

Снова нажмите кнопку **Save** (Сохранить). Сохраняется значение, введенное на второй вкладке браузера. Сохраненные значения отображаются на странице индекса.

## <a name="update-the-delete-page-model"></a>Обновление модели страницы "Delete" (Удаление)

Измените файл *Pages/Departments/Delete.cshtml.cs*, используя следующий код:

[!code-csharp[](intro/samples/cu30/Pages/Departments/Delete.cshtml.cs)]

Страница "Delete" (Удаление) обнаруживает конфликты параллелизма при изменении сущности после ее получения. `Department.RowVersion` является версией строки при получении сущности. Когда EF Core создает команду SQL DELETE, она включает предложение WHERE с `RowVersion`. Если команда SQL DELETE не затрагивает ни одной строки:

* `RowVersion` в команде SQL DELETE не соответствует `RowVersion` в базе данных.
* Возникает исключение DbUpdateConcurrencyException.
* Вызывается `OnGetAsync` с `concurrencyError`.

### <a name="update-the-delete-page"></a>Обновление страницы удаления

Измените *Pages/Departments/Delete.cshtml*, используя следующий код:

[!code-cshtml[](intro/samples/cu30/Pages/Departments/Delete.cshtml?highlight=1,10,39,42,51)]

Приведенный выше код вносит следующие изменения:

* Изменяет директиву `page` с `@page` на `@page "{id:int}"`.
* Добавляет сообщение об ошибке.
* Заменяет FirstMidName на FullName в поле **Administrator** (Администратор).
* Изменяет `RowVersion` для отображения последнего байта.
* Добавляет версию скрытых строк. Нужно добавить `RowVersion`, чтобы обратная передача привязывала значение.

### <a name="test-concurrency-conflicts"></a>Тестирование конфликтов параллелизма

Создайте тестовую кафедру.

Откройте в браузере два экземпляра страницы "Delete" (Удаление) для тестовой кафедры:

* Запустите приложение и выберите "Departments" (Кафедры).
* Щелкните правой кнопкой мыши гиперссылку **Delete** (Удалить) для тестовой кафедры и выберите пункт **Открыть на новой вкладке**.
* Щелкните гиперссылку **Edit** (Изменить) для тестовой кафедры.

На обеих вкладках браузера отображаются одинаковые сведения.

Измените бюджет на первой вкладке браузера и нажмите кнопку **Save** (Сохранить).

В браузере отображается страница индекса с измененным значением и обновленным индикатором rowVersion. Обратите внимание на обновленный индикатор rowVersion, он отображается при второй обратной передаче на другой вкладке.

Удалите тестовую кафедру со второй закладки. Отображается ошибка параллелизма с текущими значениями из базы данных. При нажатии кнопки **Delete** (Удалить) сущность удаляется, если только не был обновлен `RowVersion`.

## <a name="additional-resources"></a>Дополнительные ресурсы

* [Токены параллелизма в EF Core](/ef/core/modeling/concurrency)
* [Обработка параллелизма в EF Core](/ef/core/saving/concurrency)
* [Отладка источника ASP.NET Core 2.x](https://github.com/dotnet/AspNetCore.Docs/issues/4155)

## <a name="next-steps"></a>Следующие шаги

Это последний учебник из серии. Дополнительные темы рассматриваются в [версии этой серии для MVC](xref:data/ef-mvc/index).

> [!div class="step-by-step"]
> [Предыдущий учебник](xref:data/ef-rp/update-related-data)

::: moniker-end

::: moniker range="< aspnetcore-3.0"

Это руководство описывает, как обрабатывать конфликты, когда несколько пользователей параллельно (одновременно) изменяют одну сущность. При возникновении проблем, которые вам не удается устранить, [скачайте или просмотрите готовое приложение.](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/data/ef-rp/intro/samples) [Указания по скачиванию](xref:index#how-to-download-a-sample).

## <a name="concurrency-conflicts"></a>Конфликты параллелизма

Конфликт параллелизма возникает в следующих условиях:

* Пользователь переходит на страницу редактирования для сущности.
* Другой пользователь обновляет ту же сущность до того, как изменение первого пользователя записывается в базу данных.

Если обнаружение параллелизма отключено, возникают параллельные изменения:

* Побеждает последнее изменение. Таким образом, в базу данных заносятся значения из последнего изменения.
* Первые из текущих изменений утрачиваются.

### <a name="optimistic-concurrency"></a>Оптимистическая блокировка

Оптимистическая блокировка допускает появление конфликтов параллелизма, а затем обрабатывает их соответствующим образом. Например, Мария посещает страницу изменения кафедры и изменяет бюджет кафедры английской языка с 350 000,00 USD на 0,00 USD.

![Изменение бюджета на 0](concurrency/_static/change-budget.png)

Прежде чем Мария нажимает кнопку **Save** (Сохранить), Дмитрий заходит на ту же страницу и изменяет значение в поле "Start Date" (Дата начала) с 9/1/2007 на 9/1/2013.

![Изменение начальной даты на 2013 г.](concurrency/_static/change-date.png)

Сначала Мария нажимает кнопку **Save** (Сохранить) и видит свое изменение, когда браузер отображает страницу индекса.

![Бюджет изменен на нуль](concurrency/_static/budget-zero.png)

Дмитрий нажимает кнопку **Save** (Сохранить) на странице редактирования, где все еще отображается бюджет 350 000,00 USD. Дальнейший ход событий определяется порядком обработки конфликтов параллелизма.

Оптимистическая блокировка включает в себя следующие параметры:

* Вы можете отслеживать, для какого свойства пользователь изменил и обновил только соответствующие столбцы в базе данных.

  В этом сценарии никакие данные не теряются. Разные свойства были обновлены двумя пользователями. Когда какой-либо пользователь просмотрит кафедру английского языка в следующий раз, он увидит изменения, внесенные как Марией, так и Дмитрием. Этот способ обновления позволяет снизить количество конфликтов, способных привести к потере данных. Особенности этого подхода:
 
  * Он не позволяет избежать потери данных, если конкурирующие изменения вносятся для одного свойства.
  * Он не слишком хорошо подходит для веб-приложений, так как требует поддерживать значительный объем состояний, чтобы отслеживать все извлеченные и новые значения. Обслуживание большого объема состояний может негативно повлиять на производительность приложения.
  * Он может повысить сложность приложений по сравнению с обнаружением параллелизма для сущности.

* Вы можете позволить изменению Дмитрия перезаписать изменение Марии.

  Когда какой-либо пользователь просмотрит кафедру английского языка в следующий раз, он увидит дату 9/1/2013 и значение 350 000,00 USD. Такой подход называется *победой клиента* или *сохранением последнего внесенного изменения*. (Все значения из клиента имеют приоритет над данными в хранилище.) Если не писать код для обработки параллелизма, автоматически применяется победа клиента.

* Вы можете запретить обновление изменения Дмитрия в базе данных. Как правило приложение будет:

  * отображать сообщение об ошибке;
  * отображать текущее состояние данных;
  * разрешать пользователю повторно применять изменения.

  Это называется *победой хранилища*. (Значения в хранилище имеют приоритет над данными, передаваемыми клиентом.) В этом руководстве вы реализуете сценарий победы хранилища. Данный метод гарантирует, что никакие изменения не перезаписываются без оповещения пользователя.

## <a name="handling-concurrency"></a>Обработка параллелизма 

Если свойство настроено как [токен параллелизма](/ef/core/modeling/concurrency):

* EF Core проверяет, что свойство не было изменено после его получения. Эта проверка выполняется при вызове [SaveChanges](/dotnet/api/microsoft.entityframeworkcore.dbcontext.savechanges#Microsoft_EntityFrameworkCore_DbContext_SaveChanges) или [SaveChangesAsync](/dotnet/api/microsoft.entityframeworkcore.dbcontext.savechangesasync#Microsoft_EntityFrameworkCore_DbContext_SaveChangesAsync_System_Threading_CancellationToken_).
* Если свойство было изменено после получения, возникает исключение [DbUpdateConcurrencyException](/dotnet/api/microsoft.entityframeworkcore.dbupdateconcurrencyexception). 

Нужно настроить базу данных и модель данных для поддержки исключения `DbUpdateConcurrencyException`.

### <a name="detecting-concurrency-conflicts-on-a-property"></a>Обнаружение конфликтов параллелизма для свойства

Конфликты параллелизма можно обнаружить на уровне свойств с помощью атрибута [ConcurrencyCheck](/dotnet/api/system.componentmodel.dataannotations.concurrencycheckattribute). Этот атрибут можно применить к нескольким свойствам в модели. Дополнительные сведения см. в [описании ConcurrencyCheck в подразделе "Заметки к данным"](/ef/core/modeling/concurrency#data-annotations).

Атрибут`[ConcurrencyCheck]` в этом руководстве не используется.

### <a name="detecting-concurrency-conflicts-on-a-row"></a>Обнаружение конфликтов параллелизма для строки

Чтобы обнаружить конфликты параллелизма, в модель добавлен столбец отслеживания [rowversion](/sql/t-sql/data-types/rowversion-transact-sql).  `rowversion` :

* Относится к SQL Server. Другие базы данных могут не предоставлять подобную функцию.
* Используется для определения того, что сущность не была изменена после ее получения из базы данных. 

База данных формирует последовательный номер `rowversion`, увеличивающийся при каждом обновлении строки. В команде `Update` или `Delete` предложение `Where` включает извлеченное значение из `rowversion`. Если обновляемая строка изменились:

* `rowversion` не соответствует полученному значению.
* Команда `Update` или `Delete` не находит строку, так как предложение `Where` включает полученное значение `rowversion`.
* Возникает исключение `DbUpdateConcurrencyException`.

Когда в EF Core нет строк, обновленных командой `Update` или `Delete`, возникает исключение параллелизма.

### <a name="add-a-tracking-property-to-the-department-entity"></a>Добавление свойства отслеживания в сущность Department

В *Models/Department.cs* добавьте свойство отслеживания RowVersion:

[!code-csharp[](intro/samples/cu/Models/Department.cs?name=snippet_Final&highlight=26,27)]

Атрибут [Timestamp](/dotnet/api/system.componentmodel.dataannotations.timestampattribute) указывает, что этот столбец входит в предложение `Where` для команд `Update` и `Delete`. Этот атрибут называется `Timestamp`, так как предыдущие версии SQL Server использовали тип данных `timestamp` SQL, пока его не сменил тип `rowversion`.

Текучий API также может задавать свойство отслеживания:

```csharp
modelBuilder.Entity<Department>()
  .Property<byte[]>("RowVersion")
  .IsRowVersion();
```

В следующем коде показана часть кода T-SQL, созданного EF Core при обновлении названия кафедры:

[!code-sql[](intro/samples/cu21snapshots/sql.txt?highlight=2-3)]

Предыдущий выделенный код показывает предложение `WHERE`, содержащее `RowVersion`. Если база данных `RowVersion` не соответствует параметру `RowVersion` (`@p2`), никакие строки не обновляются.

Следующий выделенный код показывает код T-SQL, который подтверждает, что была обновлена всего одна строка.

[!code-sql[](intro/samples/cu21snapshots/sql.txt?highlight=4-6)]

[@@ROWCOUNT](/sql/t-sql/functions/rowcount-transact-sql) возвращает число строк, затронутых при выполнении последнего оператора. Если никакие строки не обновляются, EF Core выдает исключение `DbUpdateConcurrencyException`.

Вы можете просмотреть код T-SQL, создаваемый EF Core в окне вывода Visual Studio.

### <a name="update-the-db"></a>Обновление базы данных

Добавление свойства `RowVersion` изменяет модель базы данных, которая требует миграции.

Выполните построение проекта. Введите в командном окне следующее:

```dotnetcli
dotnet ef migrations add RowVersion
dotnet ef database update
```

Предыдущие команды:

* Добавляет файл миграций *Migrations/{метка времени}_RowVersion.cs*.
* Изменяет файл *Migrations/SchoolContextModelSnapshot.cs*. Это изменение добавляет следующий выделенный код в метод `BuildModel`:

  [!code-csharp[](intro/samples/cu/Migrations/SchoolContextModelSnapshot.cs?name=snippet_Department&highlight=14-16)]

* Запускает миграции для обновления базы данных.

<a name="scaffold"></a>

## <a name="scaffold-the-departments-model"></a>Формирование шаблона для модели кафедр

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio) 

Следуйте инструкциям в разделе [Формирование шаблона для модели Student](xref:data/ef-rp/intro#scaffold-student-pages) и используйте `Department` для класса модели.

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

 Выполните следующую команду:

  ```dotnetcli
  dotnet aspnet-codegenerator razorpage -m Department -dc SchoolContext -udl -outDir Pages\Departments --referenceScriptLibraries
  ```

---

Предыдущая команда формирует шаблон для модели `Department`. Откройте проект в Visual Studio.

Выполните построение проекта.

### <a name="update-the-departments-index-page"></a>Изменение страницы индекса кафедр

Подсистема формирования шаблонов создала столбец `RowVersion` для страницы индекса, однако это поле не должно отображаться. В этом руководстве отображается последний байт `RowVersion` для лучшего понимания параллелизма. Этот последний байт необязательно является уникальным. Реальное приложение не будет отображать `RowVersion` или последний байт `RowVersion`.

Обновите страницу индекса:

* Замените Index на Departments.
* Замените разметку, содержащую `RowVersion`, на последний байт `RowVersion`.
* Замените FirstMidName на FullName.

Следующая разметка показывает обновленную страницу:

[!code-cshtml[](intro/samples/cu/Pages/Departments/Index.cshtml?highlight=5,8,29,47,50)]

### <a name="update-the-edit-page-model"></a>Обновление модели страницы "Edit" (Редактирование)

Измените *Pages\Departments\Edit.cshtml.cs*, используя следующий код:

[!code-csharp[](intro/samples/cu/Pages/Departments/Edit.cshtml.cs?name=snippet)]

Для обнаружения проблемы параллелизма [OriginalValue](/dotnet/api/microsoft.entityframeworkcore.changetracking.propertyentry.originalvalue#Microsoft_EntityFrameworkCore_ChangeTracking_PropertyEntry_OriginalValue) обновляется с помощью значения `rowVersion` из сущности, откуда он был получен. EF Core создает команду SQL UPDATE с предложением WHERE, содержащим исходное значение `RowVersion`. Если команда UPDATE не затрагивает никакие строки (нет строк, имеющих исходное значение `RowVersion`), возникает исключение `DbUpdateConcurrencyException`.

[!code-csharp[](intro/samples/cu/Pages/Departments/Edit.cshtml.cs?name=snippet_rv&highlight=24-999)]

В приведенном выше коде `Department.RowVersion` является значением на момент извлечения сущности. `OriginalValue` является значением в базе данных на момент вызова `FirstOrDefaultAsync` в этом методе.

Следующий код возвращает значения клиента (значения, переданные в этот метод) и значения базы данных:

[!code-csharp[](intro/samples/cu/Pages/Departments/Edit.cshtml.cs?name=snippet_try&highlight=9,18)]

Следующий код добавляет пользовательское сообщение об ошибке для каждого столбца, у которого значения базы данных отличаются в переданных в `OnPostAsync`:

[!code-csharp[](intro/samples/cu/Pages/Departments/Edit.cshtml.cs?name=snippet_err)]

Следующий выделенный код задает для `RowVersion` новое значение, полученное из базы данных. Когда пользователь в следующий раз нажимает кнопку **Save** (Сохранить), перехватываются только те ошибки параллелизма, возникшие с момента последнего отображения страницы "Edit" (Редактирование).

[!code-csharp[](intro/samples/cu/Pages/Departments/Edit.cshtml.cs?name=snippet_try&highlight=23)]

Оператор `ModelState.Remove` является обязательным, так как `ModelState` имеет старое значение `RowVersion`. На странице Razor значение `ModelState` для поля имеет приоритет над значениями свойств модели, если они присутствуют вместе.

## <a name="update-the-edit-page"></a>Обновление страницы редактирования

Обновите *Pages/Departments/Edit.cshtml*, используя следующую разметку:

[!code-cshtml[](intro/samples/cu/Pages/Departments/Edit.cshtml?highlight=1,14,16-17,37-39)]

Предыдущая разметка:

* Изменяет директиву `page` с `@page` на `@page "{id:int}"`.
* Добавляет версию скрытых строк. Нужно добавить `RowVersion`, чтобы обратная передача привязывала значение.
* Отображает последний байт `RowVersion` в целях отладки.
* Заменяет `ViewData` на строго типизированный `InstructorNameSL`.

## <a name="test-concurrency-conflicts-with-the-edit-page"></a>Тестирование конфликтов параллелизма с использованием страницы "Edit" (Редактирование)

Откройте в браузере два экземпляра страницы "Edit" (Редактирование) для кафедры английского языка:

* Запустите приложение и выберите "Departments" (Кафедры).
* Щелкните правой кнопкой мыши гиперссылку **Edit** (Изменить) для кафедры английского языка и выберите пункт **Открыть на новой вкладке**.
* На первой вкладке щелкните гиперссылку **Edit** (Изменить) для кафедры английского языка.

На обеих вкладках браузера отображаются одинаковые сведения.

Измените имя на первой вкладке браузера и нажмите кнопку **Save** (Сохранить).

![Страница "Edit" (Редактирование) кафедры 1 после изменения](concurrency/_static/edit-after-change-1.png)

В браузере отображается страница индекса с измененным значением и обновленным индикатором rowVersion. Обратите внимание на обновленный индикатор rowVersion, он отображается при второй обратной передаче на другой вкладке.

Измените другое поле на второй вкладке браузера.

![Страница "Edit" (Редактирование) кафедры 2 после изменения](concurrency/_static/edit-after-change-2.png)

Нажмите кнопку **Сохранить**. Отображаются сообщения об ошибках для всех полей, которые не соответствуют значениям базы данных:

![Сообщение об ошибке для страницы "Edit" (Редактирование) кафедры](concurrency/_static/edit-error.png)

В этом окне браузера не планировалось изменять поле "Name" (Имя). Скопируйте и вставьте текущее значение "Languages" (Языки) в поле "Name" (Имя). Выйдите из поля с помощью клавиши TAB. Проверка на стороне клиента удаляет сообщение об ошибке.

![Сообщение об ошибке для страницы "Edit" (Редактирование) кафедры](concurrency/_static/cv.png)

Снова нажмите кнопку **Save** (Сохранить). Сохраняется значение, введенное на второй вкладке браузера. Сохраненные значения отображаются на странице индекса.

## <a name="update-the-delete-page"></a>Обновление страницы удаления

Обновите страницу "Delete" (Удаление) с помощью следующего кода:

[!code-csharp[](intro/samples/cu/Pages/Departments/Delete.cshtml.cs)]

Страница "Delete" (Удаление) обнаруживает конфликты параллелизма при изменении сущности после ее получения. `Department.RowVersion` является версией строки при получении сущности. Когда EF Core создает команду SQL DELETE, она включает предложение WHERE с `RowVersion`. Если команда SQL DELETE не затрагивает ни одной строки:

* `RowVersion` в команде SQL DELETE не соответствует `RowVersion` в базе данных.
* Возникает исключение DbUpdateConcurrencyException.
* Вызывается `OnGetAsync` с `concurrencyError`.

### <a name="update-the-delete-page"></a>Обновление страницы удаления

Измените *Pages/Departments/Delete.cshtml*, используя следующий код:

[!code-cshtml[](intro/samples/cu/Pages/Departments/Delete.cshtml?highlight=1,10,39,51)]

Приведенный выше код вносит следующие изменения:

* Изменяет директиву `page` с `@page` на `@page "{id:int}"`.
* Добавляет сообщение об ошибке.
* Заменяет FirstMidName на FullName в поле **Administrator** (Администратор).
* Изменяет `RowVersion` для отображения последнего байта.
* Добавляет версию скрытых строк. Нужно добавить `RowVersion`, чтобы обратная передача привязывала значение.

### <a name="test-concurrency-conflicts-with-the-delete-page"></a>Тестирование конфликтов параллелизма с использованием страницы "Delete" (Удаление)

Создайте тестовую кафедру.

Откройте в браузере два экземпляра страницы "Delete" (Удаление) для тестовой кафедры:

* Запустите приложение и выберите "Departments" (Кафедры).
* Щелкните правой кнопкой мыши гиперссылку **Delete** (Удалить) для тестовой кафедры и выберите пункт **Открыть на новой вкладке**.
* Щелкните гиперссылку **Edit** (Изменить) для тестовой кафедры.

На обеих вкладках браузера отображаются одинаковые сведения.

Измените бюджет на первой вкладке браузера и нажмите кнопку **Save** (Сохранить).

В браузере отображается страница индекса с измененным значением и обновленным индикатором rowVersion. Обратите внимание на обновленный индикатор rowVersion, он отображается при второй обратной передаче на другой вкладке.

Удалите тестовую кафедру со второй закладки. Отображается ошибка параллелизма с текущими значениями из базы данных. При нажатии кнопки **Delete** (Удалить) сущность удаляется, если только не был обновлен `RowVersion`.

Сведения о том, как наследовать модель данных, см. в разделе [Наследование](xref:data/ef-mvc/inheritance).

### <a name="additional-resources"></a>Дополнительные ресурсы

* [Токены параллелизма в EF Core](/ef/core/modeling/concurrency)
* [Обработка параллелизма в EF Core](/ef/core/saving/concurrency)
* [Версия руководства на YouTube (обработка конфликтов параллелизма)](https://youtu.be/EosxHTFgYps)
* [Версия руководства на YouTube (часть 2)](https://www.youtube.com/watch?v=kcxERLnaGO0)
* [Версия руководства на YouTube (часть 3)](https://www.youtube.com/watch?v=d4RbpfvELRs)

> [!div class="step-by-step"]
> [Назад](xref:data/ef-rp/update-related-data)

::: moniker-end

