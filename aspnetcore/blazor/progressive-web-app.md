---
title: Создание прогрессивных веб-приложений с помощью ASP.NET Core Blazor WebAssembly
author: guardrex
description: Сведения о создании на основе Blazor прогрессивных веб-приложений, то есть приложений, которые используют функции современного браузера и реализуют поведение, свойственное классическим приложениям.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 01/11/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: 1706d3502dc68f1c25e0c35ba8f5dd44b55ce690
ms.sourcegitcommit: cc405f20537484744423ddaf87bd1e7d82b6bdf0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/21/2021
ms.locfileid: "98658655"
---
# <a name="build-progressive-web-applications-with-aspnet-core-blazor-webassembly"></a>Создание прогрессивных веб-приложений с помощью ASP.NET Core Blazor WebAssembly

Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)

Прогрессивное веб-приложение — это обычно одностраничное приложение (SPA), которое использует API и функциональные возможности современного браузера, реализуя свойственное классическим приложениям поведение. Blazor WebAssembly — это стандартизированная клиентская платформа веб-приложений с поддержкой API любых браузеров, в том числе API-интерфейсы прогрессивных веб-приложений (PWA), требуемых для реализации следующих возможностей:

* работа в автономном режиме и мгновенная загрузка вне зависимости от скорости сети;
* возможность запуска в отдельном окне приложения, а не только в окне браузера;
* запуск из меню "Пуск", меню закрепления или с начального экрана основной операционной системы (ОС);
* получение push-уведомлений от внутреннего сервера, даже если пользователь не работает с приложением;
* автоматическое обновление в фоновом режиме.

Слово *прогрессивное* используется для описания таких приложений по следующим причинам:

* на начальном этапе пользователь может открывать и использовать приложение в своем веб-браузере аналогично любому другому одностраничному приложению;
* затем его можно установить в своей ОС и включить push-уведомления.

## <a name="create-a-project-from-the-pwa-template"></a>Создание проекта на основе шаблона PWA

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

При создании **приложения Blazor WebAssembly** в диалоговом окне **Создание нового проекта** установите флажок **Прогрессивное веб-приложение**.

![Установленный флажок "Прогрессивное веб-приложение" в диалоговом окне создания проекта Visual Studio.](progressive-web-app/_static/image1.png)

<!--

# [Visual Studio for Mac](#tab/visual-studio-mac)

-->

# <a name="visual-studio-code--net-core-cli"></a>[Visual Studio Code или .NET Core CLI](#tab/visual-studio-code+netcore-cli)

Выполните следующую команду, чтобы создать проект PWA в командной оболочке с параметром `--pwa`:

```dotnetcli
dotnet new blazorwasm -o MyBlazorPwa --pwa
```

В предыдущей команде параметр `-o|--output` создает новую папку для приложения с именем `MyBlazorPwa`.

---

При необходимости PWA можно настроить для приложения, созданного на основе размещенного шаблона ASP.NET Core. Сценарий прогрессивного веб-приложения не зависит от модели размещения.

## <a name="convert-an-existing-blazor-webassembly-app-into-a-pwa"></a>Преобразование существующего приложения Blazor WebAssembly в PWA

В этом разделе приводятся указания по преобразованию существующего приложения Blazor WebAssembly в PWA.

В файле проекта приложения:

* Добавьте указанное ниже свойство `ServiceWorkerAssetsManifest` в `PropertyGroup`:

  ```xml
    ...
    <ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
  </PropertyGroup>
   ```

* Добавьте указанный ниже элемент `ServiceWorker` в `ItemGroup`:

  ```xml
  <ItemGroup>
    <ServiceWorker Include="wwwroot\service-worker.js" 
      PublishedContent="wwwroot\service-worker.published.js" />
  </ItemGroup>
  ```

Для получения статических ресурсов воспользуйтесь **одним** из следующих подходов:

::: moniker range=">= aspnetcore-5.0"

* Создайте отдельный новый проект PWA с помощью команды [`dotnet new`](/dotnet/core/tools/dotnet-new) в командной оболочке:

  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa
  ```
  
  В предыдущей команде параметр `-o|--output` создает новую папку для приложения с именем `MyBlazorPwa`.
  
  Если вы не преобразуете приложение для использования в последнем выпуске, передайте параметр `-f|--framework`. В следующем примере создается приложение для ASP.NET Core версии 3.1:
  
  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa -f netcoreapp3.1
  ```

* Перейдите по следующему URL-адресу в репозиторий GitHub для ASP.NET Core, который содержит ссылки на справочные материалы и ресурсы по выпуску 5.0. Если вы не преобразуете приложение для выпуска 5.0, выберите выпуск, с которым вы работаете, в раскрывающемся списке **Переключение ветвей или тегов** для вашего приложения.

  [dotnet/aspnetcore (выпуск 5.0), шаблон проекта Blazor WebAssembly, папка `wwwroot`](https://github.com/dotnet/aspnetcore/tree/release/5.0/src/ProjectTemplates/Web.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

::: moniker-end

::: moniker range="< aspnetcore-5.0"

* Создайте отдельный новый проект PWA с помощью команды [`dotnet new`](/dotnet/core/tools/dotnet-new) в командной оболочке. Передайте параметр `-f|--framework`, чтобы выбрать версию. В следующем примере создается приложение для ASP.NET Core версии 3.1:
  
  ```dotnetcli
  dotnet new blazorwasm -o MyBlazorPwa --pwa -f netcoreapp3.1
  ```
  
  В предыдущей команде параметр `-o|--output` создает новую папку для приложения с именем `MyBlazorPwa`.

* Перейдите по следующему URL-адресу в репозиторий GitHub для ASP.NET Core, который содержит ссылки на справочные материалы и ресурсы по выпуску 3.1:

  [dotnet/aspnetcore (выпуск 3.1), шаблон проекта Blazor WebAssembly, папка `wwwroot`](https://github.com/dotnet/aspnetcore/tree/release/3.1/src/ProjectTemplates/ComponentsWebAssembly.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

  > [!NOTE]
  > URL-адрес шаблона проекта Blazor WebAssembly изменился после выпуска ASP.NET Core 3.1. Справочные ресурсы для выпуска 5.0 и более поздних доступны по следующему URL-адресу:
  >
  > [dotnet/aspnetcore (выпуск 5.0), шаблон проекта Blazor WebAssembly, папка `wwwroot`](https://github.com/dotnet/aspnetcore/tree/release/5.0/src/ProjectTemplates/Web.ProjectTemplates/content/ComponentsWebAssembly-CSharp/Client/wwwroot)

::: moniker-end

Скопируйте следующие файлы из папки `wwwroot` источника в созданном вами приложении или из справочных ресурсов в репозитории GitHub `dotnet/aspnetcore` в папку `wwwroot` приложения:

* `icon-512.png`
* `manifest.json`
* `service-worker.js`
* `service-worker.published.js`

В файле `wwwroot/index.html` приложения:

* Добавьте элементы `<link>` для манифеста и значка приложения:

  ```html
  <link href="manifest.json" rel="manifest" />
  <link rel="apple-touch-icon" sizes="512x512" href="icon-512.png" />
  ```

* Добавьте следующий тег `<script>` в закрывающий тег `</body>` сразу после тега скрипта `blazor.webassembly.js`:

  ```html
      ...
      <script>navigator.serviceWorker.register('service-worker.js');</script>
  </body>
  ```

## <a name="installation-and-app-manifest"></a>Установка и манифест приложения

При посещении приложения, созданного с использованием параметра шаблона прогрессивного веб-приложения, пользователи могут установить его в меню "Пуск", меню закрепления или на начальном экране своей операционной системы. Порядок применения этого параметра зависит от того, какой браузер используется. В классических версиях браузеров на основе Chromium, таких как Microsoft Edge или Chrome, в строке URL-адреса появляется кнопка **Добавить**. После того как пользователь нажмет кнопку **Добавить**, отобразится диалоговое окно подтверждения.

![Диалоговое окно подтверждения в Google Chrome с кнопкой "Установить" для приложения MyBlazorPwa.](progressive-web-app/_static/image2.png)

В iOS посетители могут установить прогрессивное веб-приложение с помощью кнопки **Поделиться** в браузере Safari, а также используя параметр **Добавить на главный экран**. В браузере Chrome для Android для этой цели следует нажать кнопку **Меню** в правом верхнем углу окна, а затем выбрать команду **Добавить на главный экран**.

После установки приложение будет открываться в отдельном окне без адресной строки.

![Приложение "MyBlazorPwa" в Google Chrome без адресной строки.](progressive-web-app/_static/image3.png)

Чтобы настроить заголовок окна, цветовую схему, значок или другие сведения, используйте файл `manifest.json` в каталоге `wwwroot` проекта. Схема этого файла соответствует веб-стандартам. Дополнительные сведения см. в [веб-документации MDN: манифест веб-приложения](https://developer.mozilla.org/docs/Web/Manifest).

## <a name="offline-support"></a>Поддержка автономной работы

По умолчанию приложения, созданные с помощью шаблона прогрессивного веб-приложения, поддерживают работу в автономном режиме. Для этого пользователь должен сначала посетить приложение при наличии подключения к сети. Браузер автоматически скачает и кэширует все ресурсы, необходимые для его работы в автономном режиме.

> [!IMPORTANT]
> Поддержка разработки может помешать типовому циклу разработки, предусматривающему внесение изменений и их тестирование. Поэтому поддержка работы в автономном режиме доступна только для *опубликованных* приложений. 

> [!WARNING]
> Если вы планируете распространять прогрессивное веб-приложение с поддержкой автономного режима, следует обратить внимание на [несколько важных предупреждений и предостережений](#caveats-for-offline-pwas). Эти сценарии присущи всем поддерживающим автономную работу прогрессивным веб-приложениям и не являются специфичными для Blazor. Прежде чем планировать работу своего приложения, поддерживающего автономный режим, внимательно ознакомьтесь с этими предупреждениями и убедитесь, что они вам понятны.

Чтобы ознакомиться с принципами поддержки автономного режима:

1. Опубликуйте приложение. Для получения дополнительной информации см. <xref:blazor/host-and-deploy/index#publish-the-app>.
1. Разверните приложение на сервере, который поддерживает протокол HTTPS, и получите доступ к приложению в браузере по его защищенному HTTPS-адресу.
1. Откройте средства разработки браузера и убедитесь, что для узла на вкладке **Приложение** зарегистрирована *рабочая роль службы*.

   ![Вкладка "Приложение" в средствах разработки Google Chrome с активированной и выполняемой рабочей ролью службы.](progressive-web-app/_static/image4.png)

1. Перезагрузите страницу и перейдите на вкладку **Сеть**. Для всех ресурсов страницы в качестве источников указаны **рабочая роль службы** или **кэш памяти**.

   ![Вкладка "Сеть" в средствах разработки Google Chrome с источниками для всех ресурсов страницы.](progressive-web-app/_static/image5.png)

1. Чтобы убедиться, что для загрузки приложения браузеру не требуется доступ к сети:

   * Завершите работу веб-сервера и проверьте, как приложение продолжит работу в обычном режиме, включая перезагрузку страниц. Аналогичным образом приложение продолжает обычную работу при снижении скорости сетевого подключения.
   * Имитируйте работу в автономном режиме на вкладке **Сеть**.

   ![Вкладка "Сеть" в средствах разработки Google Chrome с раскрывающимся списком режимов браузера — изменяется с "В сети" на "Автономный".](progressive-web-app/_static/image6.png)

Поддержка работы в автономном режиме с помощью рабочей роли службы является веб-стандартом, не относящимся к Blazor. Дополнительные сведения о рабочих ролях служб см. в [веб-документации MDN: API рабочей роли службы](https://developer.mozilla.org/docs/Web/API/Service_Worker_API). Дополнительные сведения об общих шаблонах использования рабочих ролей служб см. в статье [Google Web: жизненный цикл рабочей роли службы](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).

Шаблон прогрессивного веб-приложения Blazor создает два файла рабочей роли службы:

* `wwwroot/service-worker.js`, который используется во время разработки;
* `wwwroot/service-worker.published.js`, который используется после публикации приложения.

Чтобы использовать общую логику для этих двух файлов рабочих ролей службы, рассмотрите следующий подход.

* Добавьте третий файл JavaScript для хранения общей логики.
* Используйте [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts), чтобы загрузить общую логику в оба файла рабочей роли службы.

### <a name="cache-first-fetch-strategy"></a>Стратегия первичного обращения к кэшу

Встроенная рабочая роль службы `service-worker.published.js` выполняет разрешение запросов с применением стратегии *первичного обращения к кэшу*. Это означает, что даже при наличии доступа к сети или нового содержимого на сервере во всех возможных случаях рабочая роль службы отдает предпочтение возвращаемому из кэша содержимому.

Такая стратегия полезна по следующим причинам.

* **Во-первых, за счет этого повышается надежность.** Состояние доступа к сети сложно определить однозначно, поскольку пользователь не всегда просто находится в подключенном или автономном режиме.

  * Даже при наличии подключения его скорость может быть настолько мала, что ожидание загрузки содержимого может быть нецелесообразно.
  * Для некоторых URL-адресов из сети могут возвращаться недопустимые результаты, как, например, в случае с порталом перехвата Wi-Fi, который блокирует или перенаправляет определенные запросы.
  
  Именно поэтому API `navigator.onLine` браузера не может считаться надежным источником, на который следует полагаться в приложении.

* **Во-вторых, это позволяет гарантировать корректность.** При создании кэша автономных ресурсов рабочая роль службы хэширует содержимое, чтобы гарантировать получение полного и согласованного моментального снимка ресурсов по состоянию на один конкретный момент времени. В дальнейшем этот кэш используется в качестве атомарной единицы. Запрашивать более новые версии ресурсов из сети нецелесообразно, поскольку все данные, которые требуются, уже хранятся в кэше. Любые другие данные могут стать причиной несогласованности и несовместимости, например при попытке использовать версии сборок .NET, которые не компилировались вместе.

### <a name="background-updates"></a>Обновления в фоновом режиме

Для наглядности прогрессивное веб-приложение с предпочтительным автономным режимом работы можно рассматривать как устанавливаемое мобильное приложение. Оно запускается немедленно, независимо от наличия сетевого подключения, однако при этом логика установленного приложения извлекается из моментального снимка на определенный момент времени, который может содержать устаревшие данные.

На основе шаблона прогрессивного веб-приложения Blazor создаются приложения, которые пытаются автоматически выполнить обновление в фоновом режиме при наличии работающего сетевого подключения каждый раз, когда приложение посещает пользователь. Этот процесс реализуется следующим образом:

* Во время компиляции проект создает *манифест ресурсов рабочей роли службы*. По умолчанию это `service-worker-assets.js`. В нем перечислены все статические ресурсы, которые требуются для работы приложения в автономном режиме, например сборки .NET, файлы JavaScript и каскадные таблицы стилей, в том числе хэши содержимого. Рабочая роль службы загружает список ресурсов и использует его для определения ресурсов, которые требуется кэшировать.
* Каждый раз, когда пользователь открывает приложение, браузер повторно запрашивает `service-worker.js` и `service-worker-assets.js` в фоновом режиме. Файлы сравниваются побайтово с существующей установленной рабочей ролью службы. Если сервер возвращает измененное содержимое для любого из этих файлов, рабочая роль службы пытается установить собственную новую версию.
* При установке собственной новой версии рабочая роль службы создает новый отдельный кэш для автономных ресурсов и начинает заполнять кэш ресурсами, перечисленными в файле `service-worker-assets.js`. Эта логика реализуется в функции `onInstall` в файле `service-worker.published.js`.
* Процесс завершается успешно, когда все ресурсы загружаются без ошибок и все хэши содержимого совпадают. В случае успешного выполнения новая рабочая роль службы переходит в состояние *ожидания активации*. Как только пользователь закроет приложение (т. е. все вкладки или окна, в которых оно отображается), новая рабочая роль службы становится *активной* и используется при последующем посещении приложения. Старая рабочая роль службы и ее кэш при этом удаляются.
* Если процесс завершается неудачно, новый экземпляр рабочей роли службы отклоняется. При следующем посещении пользователя будет предпринята попытка выполнить процесс обновления еще раз в расчете на более высокое качество сетевого подключения и возможность выполнения необходимых запросов.

Настроить этот процесс можно, используя логику рабочей роли службы. Все перечисленные выше варианты не являются специфичными для Blazor, однако описывают стандартный способ использования шаблона прогрессивного веб-приложения. Дополнительные сведения см. в [веб-документации MDN: API рабочей роли службы](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).

### <a name="how-requests-are-resolved"></a>Принципы разрешения запросов

Как описывается выше в разделе [Стратегия первичного обращения к кэшу](#cache-first-fetch-strategy), по умолчанию рабочая роль службы применяет стратегию *первичного обращения к кэшу*, то есть пытается по возможности всегда использовать кэшированное содержимое. Если для отдельного URL-адреса кэшированное содержимое отсутствует (например, в случае запроса данных из серверного API), рабочая роль службы использует обычные сетевые запросы, которые выполняются успешно только при наличии доступа к серверу. Эта логика реализуется в функции `onFetch` в файле `service-worker.published.js`.

Если компоненты приложения Razor запрашивают данные из серверных API и вам требуется удобный пользовательский интерфейс для обработки сбоев, связанных с отсутствием доступа к сети, то соответствующую логику необходимо реализовать в самих компонентах приложения. Например, используйте `try/catch` для запросов <xref:System.Net.Http.HttpClient>.

### <a name="support-server-rendered-pages"></a>Поддержка страниц, подготавливаемых к просмотру на сервере

Рассмотрим, что происходит при первом переходе пользователя к URL-адресу, например к `/counter`, или по любой другой прямой ссылке в приложении. В таких случаях вам не нужно возвращать кэшированное содержимое как `/counter`. Вместо этого нужно загрузить в браузер содержимое, кэшированное как `/index.html`, для запуска приложения Blazor WebAssembly. Такие начальные запросы называются *запросами навигации* в отличие от следующих запросов:

* запросов `subresource` для получения изображений, таблиц стилей или других файлов;
* запросов `fetch/XHR` для получения данных API.

По умолчанию рабочая роль службы использует для обработки запросов навигации специальную логику. Рабочая роль службы разрешает такие запросы путем возврата кэшированного содержимого для `/index.html`, независимо от того, какой URL-адрес запрашивается. Эта логика реализуется в функции `onFetch` в файле `service-worker.published.js`.

Если для некоторых URL-адресов в вашем приложении должен возвращаться подготавливаемый к просмотру на сервере код HTML (то есть для обслуживания `/index.html` не должен использоваться кэш), вам потребуется изменить логику рабочей роли службы. Если все URL-адреса, содержащие `/Identity/`, требуется обрабатывать как обычные сетевые запросы к серверу, следует изменить логику функции `onFetch` в файле `service-worker.published.js`. Найдите следующий код.

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

Измените код следующим образом:

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
  && !event.request.url.includes('/Identity/');
```

Если этого не сделать, то, независимо от наличия сетевого подключения, рабочая роль службы будет перехватывать запросы к таким URL-адресам и разрешать их с помощью `/index.html`.

Добавьте в проверку конечные точки для внешних поставщиков проверки подлинности. В следующем примере в проверку добавляется `/signin-google` для проверки подлинности Google:

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
  && !event.request.url.includes('/Identity/')
  && !event.request.url.includes('/signin-google');
```

Не требуется выполнять никаких действий для среды разработки, где содержимое всегда извлекается из сети.

### <a name="control-asset-caching"></a>Управление кэшированием ресурсов

Если в вашем проекте определено свойство MSBuild `ServiceWorkerAssetsManifest`, средства сборки Blazor создадут манифест ресурса рабочей роли службы с указанным именем. По умолчанию шаблон прогрессивного веб-приложения создает файл проекта со следующим свойством.

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

Этот файл помещается в выходной каталог `wwwroot`, откуда браузер может извлекать его посредством запроса `/service-worker-assets.js`. Чтобы просмотреть содержимое этого файла, откройте `/bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js` в текстовом редакторе. Не вносите изменения в этот файл, поскольку он создается заново при каждой сборке.

По умолчанию этот манифест содержит следующие данные:

* Все управляемые Blazor ресурсы, в том числе сборки .NET и файлы среды выполнения .NET WebAssembly, которые требуются для работы в автономном режиме.
* Все ресурсы, которые будут опубликованы в каталоге `wwwroot` приложения, такие как изображения, таблицы стилей и файлы JavaScript. К ним также относятся статические веб-ресурсы, предоставляемые в составе внешних проектов и пакетов NuGet.

Чтобы управлять получением и кэшированием этих ресурсов в рабочей роли службы, измените логику функции `onInstall` в файле `service-worker.published.js`. По умолчанию рабочая роль службы получает и кэширует файлы с типичными для веб-файлов расширениями, такими как `.html`, `.css`, `.js` и `.wasm`, а также характерные для Blazor WebAssembly файлы (`.dll`, `.pdb`).

Чтобы включить другие ресурсы, отсутствующие в каталоге `wwwroot` приложения, определите дополнительные записи `ItemGroup` MSBuild, как показано в следующем примере.

```xml
<ItemGroup>
  <ServiceWorkerAssetsManifestItem Include="MyDirectory\AnotherFile.json"
    RelativePath="MyDirectory\AnotherFile.json" AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

В метаданных `AssetUrl` указывается относительный URL-адрес, который браузер должен использовать при получении ресурса в кэш. При этом имя оригинального исходного файла на диске может не учитываться.

> [!IMPORTANT]
> Добавление `ServiceWorkerAssetsManifestItem` не приводит к публикации файла в каталог `wwwroot` приложения. Управление выходными данными публикации следует организовать отдельно. В результате добавления `ServiceWorkerAssetsManifestItem` в манифесте ресурса рабочей роли службы лишь появляется дополнительная запись.

## <a name="push-notifications"></a>Push-уведомления

Как и любые аналоги, прогрессивные веб-приложения Blazor WebAssembly поддерживают получение push-уведомлений от внутреннего сервера. Сервер может отправлять такие уведомления в любое время, даже если приложение не используется активно (например, если другой пользователь выполняет действие, о котором требуется оповестить).

Механизм отправки push-уведомлений не зависит от Blazor WebAssembly, так как он реализуется на внутреннем сервере, который может использовать любую технологию. Для отправки push-уведомлений с сервера ASP.NET Core рекомендуется [использовать методику, аналогичную описываемой в рамках семинара по проекту Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).

Механизм приема и отображения push-уведомлений на стороне клиента также реализуется независимо от Blazor WebAssembly в файле JavaScript рабочей роли службы. Рекомендуем обратиться к [семинару, посвященному проекту Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).

## <a name="caveats-for-offline-pwas"></a>Предупреждения относительно прогрессивных веб-приложений с поддержкой автономной работы

Поддержка работы в автономном режиме требуется не для всех приложений. С ее реализацией сопряжены определенные сложности, решение которых не всегда целесообразно.

Поддержка автономной работы как правило требуется лишь в следующих случаях:

* Браузер использует преимущественно локальное основное хранилище данных. В качестве примера можно привести разработку пользовательского интерфейса для устройства [Интернета вещей](https://en.wikipedia.org/wiki/Internet_of_things), которое хранит данные в `localStorage` или [индексированной базе данных](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).
* Приложение тратит значительный объем ресурсов на получение и кэширование данных серверного API для каждого пользователя, чтобы они могли работать с такими данными в автономном режиме. Если приложение должно поддерживать редактирование, потребуется создать систему, которая будет отслеживать изменения и синхронизировать их с серверной частью.
* Необходимо гарантировать мгновенную загрузку приложения независимо от состояния сетевого подключения. Реализуйте соответствующий пользовательский интерфейс для работы с запросами к серверному API и корректного разрешения ситуаций, когда они завершаются сбоем из-за отсутствия доступа к сети.

Кроме того, поддержка работы в автономном режиме для прогрессивных веб-приложений сопряжена с рядом дополнительных сложностей. Разработчикам следует внимательно изучить предостережения, приведенные в разделах ниже.

### <a name="offline-support-only-when-published"></a>Работа в автономном режиме поддерживается только для опубликованных приложений

В процессе разработки каждое изменение, как правило, должно сразу отражаться в браузере, не дожидаясь обновления в фоновом режиме. Поэтому шаблон прогрессивного веб-приложения Blazor обеспечивает поддержку автономной работы только после публикации приложения.

При создании приложения, поддерживающего автономную работу, недостаточно протестировать его в режиме разработки. Вам придется проверить приложение в опубликованном состоянии, чтобы понять, как оно будет вести себя при различных состояниях сети.

### <a name="update-completion-after-user-navigation-away-from-app"></a>Обновление выполняется только после выхода пользователя из приложения

Обновления будут выполняться только после того, как пользователь выйдет из приложения на всех вкладках. Как поясняется в разделе [Обновления в фоновом режиме](#background-updates), после развертывания и обновления приложения браузер получит обновленные файлы рабочей роли службы, чтобы запустить процесс обновления.

Однако далеко не все разработчики знают, что даже после завершения процесса обновления оно вступит в силу **только после того**, как пользователь выйдет из приложения на всех вкладках. Даже если ваше приложение отображается только в одной вкладке, простого ее обновления будет **недостаточно**. Пока пользователь не закроет приложение полностью, новая рабочая роль службы будет оставаться в состоянии *ожидания активации*. **Такое поведение присуще всем веб-платформам и не является специфичным для Blazor.**

Соответственно, многие разработчики сталкиваются с проблемами при попытке протестировать обновления рабочей роли службы или кэшированных автономно ресурсов. Открыв средства разработчика в браузере, вы можете увидеть нечто подобное:

![Вкладка "Приложение" в Google Chrome с рабочей ролью службы приложения в состоянии ожидания активации.](progressive-web-app/_static/image7.png)

Рабочая роль будет находиться в состоянии ожидания до тех пор, пока список "клиентов" (т. е. вкладок или окон, в которых отображается приложение) не опустеет. Это необходимо для обеспечения согласованности. Согласованность означает получение всех ресурсов из одного атомарного кэша.

При тестировании изменений может быть удобно воспользоваться ссылкой skipWaiting, которая позволяет пропустить этап ожидания (см. снимок экрана выше), и затем перезагрузить страницу. Можно автоматизировать этот процесс для всех пользователей, реализовав в коде рабочей роли службы [пропуск этапа "ожидания" с немедленной активацией обновления](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase). Если пропустить этап ожидания, согласованное получение ресурсов из одного и того же экземпляра кэша не гарантируется.

### <a name="users-may-run-any-historical-version-of-the-app"></a>Пользователи могут запускать любую ранее существовавшую версию приложения

Как правило, разработчики веб-приложения ожидают, что пользователи будут работать только с его последней развернутой версией, поскольку это характерно для традиционной модели распространения. Тем не менее прогрессивное веб-приложение с предпочтительным автономным режимом работы в этом отношении больше похоже на собственное мобильное приложение, пользователи которого далеко не всегда работают с последней версией.

Как описывается в разделе [Обновления в фоновом режиме](#background-updates), после развертывания обновления для приложения **все его текущие пользователи будут работать с предыдущей версией как минимум во время ближайшего посещения**, поскольку обновление происходит в фоновом режиме только после того, как пользователь выйдет из приложения. Кроме того, в этом случае предыдущей используемой версией не обязательно будет та, которую вы развернули в прошлый раз. В зависимости от того, когда пользователь последний раз выполнял обновление, это может быть *любая* ранее существовавшая версия.

Таким образом, если внешние и внутренние компоненты приложения должны использовать согласованную схему для работы с запросами к API, это может привести к возникновению проблем. Соответственно, развертывать изменения схемы API, не предусматривающие обратную совместимость, можно только после того, как вы убедитесь, что все пользователи выполнили обновление. Также в таких случаях можно явно запретить использование несовместимых старых версий приложения. Это требование к сценарию аналогично тому, которое применяется для собственных мобильных приложений. При развертывании существенных изменений в серверных API пользователи, не выполнившие обновление, столкнутся со сбоями в работе клиентского приложения.

Соответственно, по возможности не следует развертывать существенные изменения в серверных API. Если это все же необходимо, рекомендуется использовать [стандартные API рабочей роли службы, такие как ServiceWorkerRegistration](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration), для определения актуальности версии приложения и блокировки его старых версий.

### <a name="interference-with-server-rendered-pages"></a>Возникают помехи в работе подготавливаемых к просмотру на сервере страниц

Как описывается выше в разделе [Поддержка страниц, подготавливаемых к просмотру на сервере](#support-server-rendered-pages), чтобы обойти поведение рабочей роли службы и предотвратить возврат содержимого `/index.html` для всех запросов навигации, измените логику рабочей роли службы.

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a>По умолчанию кэшируется все содержимое манифеста ресурса рабочей роли службы

Как описывается выше в разделе [Управление кэшированием ресурсов](#control-asset-caching), файл `service-worker-assets.js` создается в процессе сборки и содержит список всех ресурсов, которые должна получать и кэшировать рабочая роль службы.

Поскольку в этот список по умолчанию включается все содержимое, размещаемое в каталоге `wwwroot`, в том числе и поступающее из внешних пакетов и проектов, необходимо тщательно следить за тем, чтобы в этом каталоге не было слишком много содержимого. Если каталог `wwwroot` содержит несколько миллионов изображений, рабочая роль службы попытается получить и кэшировать их все, что приведет к перегрузке сети и, скорее всего, закончится сбоем.

Реализуйте произвольную логику, ограничивающую получение и кэширование содержимого манифеста, внеся соответствующие изменения в функцию `onInstall` в файле `service-worker.published.js`.

### <a name="interaction-with-authentication"></a>Взаимодействие с технологиями проверки подлинности

Шаблон PWA можно использовать вместе с проверкой подлинности. Прогрессивные веб-приложения с поддержкой автономной работы также могут обеспечивать проверку подлинности при наличии у пользователя начального подключения к сети.

В случае отсутствия сетевого подключения пользователь не сможет пройти проверку подлинности или получить маркеры доступа. По умолчанию при попытке перейти на страницу входа при отсутствии доступа к сети будет отображаться сообщение об ошибке сети. Необходимо организовать работу пользователя в автономном режиме таким образом, чтобы для выполнения задач при отсутствии сетевого подключения не требовались маркеры доступа или проверка подлинности. Либо должны быть предусмотрены способы минимизировать последствия сбоев в таких случаях. Если реализовать это в приложении невозможно, следует задуматься, действительно ли в нем необходима поддержка работы в автономном режиме.

Если приложение, предназначенное для работы в сети и в автономном режиме, снова подключено к сети:

* приложению может потребоваться подготовить новый маркер доступа;
* приложение должно определить, вошел ли другой пользователь в службу, чтобы применить к учетной записи пользователя операции, выполненные в автономном режиме.

Чтобы создать автономное приложение PWA, взаимодействующее с проверкой подлинности:

* замените <xref:Microsoft.AspNetCore.Components.WebAssembly.Authentication.AccountClaimsPrincipalFactory%601> фабрикой, которая хранит последнего пользователя, выполнившего вход, и использует сохраненного пользователя, когда приложение находится в автономном режиме;
* поместите операции в очередь, пока приложение находится в автономном режиме, и примените их при переходе приложения в режим "в сети";
* во время выхода очистите сохраненного пользователя.

Описанные выше подходы демонстрируются в примере приложения [`CarChecker`](https://github.com/SteveSandersonMS/CarChecker). Ознакомьтесь со следующими частями приложения:

* `OfflineAccountClaimsPrincipalFactory` (`Client/Data/OfflineAccountClaimsPrincipalFactory.cs`)
* `LocalVehiclesStore` (`Client/Data/LocalVehiclesStore.cs`)
* Компонент `LoginStatus` (`Client/Shared/LoginStatus.razor`)

## <a name="additional-resources"></a>Дополнительные ресурсы

* [Скрипт PowerShell для устранения проблем целостности](xref:blazor/host-and-deploy/webassembly#troubleshoot-integrity-powershell-script)
* [Согласование независимо от источника для проверки подлинности для SignalR](xref:blazor/fundamentals/additional-scenarios#signalr-cross-origin-negotiation-for-authentication)
