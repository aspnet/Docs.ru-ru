---
title: Общие сведения о пользовательских интерфейсах API для ASP.NET Core
author: rick-anderson
description: Получите краткий обзор различных интерфейсов API потребителя, доступных в ASP.NET Coreной библиотеке защиты данных.
ms.author: riande
ms.date: 06/11/2019
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/consumer-apis/overview
ms.openlocfilehash: 485ea3f669b518f2979d04493b281bd116b05f65
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2020
ms.locfileid: "93051880"
---
# <a name="consumer-apis-overview-for-aspnet-core"></a>Общие сведения о пользовательских интерфейсах API для ASP.NET Core

`IDataProtectionProvider`Интерфейсы и `IDataProtector` являются основными интерфейсами, через которые потребители используют систему защиты данных. Они расположены в пакете [Microsoft. AspNetCore. в отношении защиты. абстракций](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) .

## <a name="idataprotectionprovider"></a>идатапротектионпровидер

Интерфейс поставщика представляет корень системы защиты данных. Его нельзя использовать напрямую для защиты или снятия защиты данных. Вместо этого потребитель должен получить ссылку на, `IDataProtector` вызвав `IDataProtectionProvider.CreateProtector(purpose)` , где назначение — это строка, описывающая предполагаемый вариант использования потребителя. Дополнительные сведения о намерении этого параметра и о том, как выбрать соответствующее значение, см. в разделе [строки назначения](xref:security/data-protection/consumer-apis/purpose-strings) .

## <a name="idataprotector"></a>идатапротектор

Интерфейс предохранителя возвращается вызовом метода `CreateProtector` , и это интерфейс, который потребители могут использовать для выполнения операций защиты и снятия защиты.

Чтобы защитить фрагмент данных, передайте данные в `Protect` метод. Базовый интерфейс определяет метод, который преобразует Byte [] — > Byte [], но существует также перегрузка (предоставленная в виде метода расширения), преобразующая строку строкового >. Безопасность, предоставляемая двумя методами, идентична. разработчик должен выбрать любую перегрузку, наиболее удобную для своего случая использования. Независимо от выбранной перегрузки, значение, возвращаемое методом Protect, теперь защищено (зашифрованные и искажение), и приложение может отправить его на недоверенный клиент.

Чтобы снять защиту с ранее защищенного фрагмента данных, передайте защищенные данные в `Unprotect` метод. (Для удобства разработчика существуют перегрузки на основе байтов [] и на основе строк.) Если защищенные полезные данные были созданы предыдущим вызовом в `Protect` `IDataProtector` , `Unprotect` метод вернет исходные незащищенные полезные данные. Если защищенные полезные данные были изменены или были созданы другим `IDataProtector` `Unprotect` методом, метод вызовет CryptographicException.

Концепция одних и тех же `IDataProtector` взаимосвязей обратно в концепцию цели. Если два `IDataProtector` экземпляра были созданы из одного корня, `IDataProtectionProvider` но с помощью разных строк назначения в вызове `IDataProtectionProvider.CreateProtector` , они считаются [разными предохранителями](xref:security/data-protection/consumer-apis/purpose-strings), и один из них не сможет снять защиту полезных данных, созданных другим.

## <a name="consuming-these-interfaces"></a>Использование этих интерфейсов

Для компонента, поддерживающего внедрение, предполагаемое использование заключается в том, что компонент принимает `IDataProtectionProvider` параметр в конструкторе и что система di автоматически предоставляет эту службу при создании экземпляра компонента.

> [!NOTE]
> Некоторые приложения (например, консольные приложения или приложения ASP.NET 4. x) не поддерживают DI, поэтому не могут использовать описанный здесь механизм. В этих сценариях для получения дополнительных сведений о получении экземпляра поставщика без использования инструкции ondi см. документацию по [сценариям, не поддерживающим](xref:security/data-protection/configuration/non-di-scenarios) внедрение `IDataProtection` .

В следующем примере показаны три концепции.

1. [Добавьте систему защиты данных](xref:security/data-protection/configuration/overview) в контейнер службы.

2. Использование метода DI для получения экземпляра класса `IDataProtectionProvider` , и

3. Создание `IDataProtector` из `IDataProtectionProvider` и использование его для защиты и снятия защиты данных.

[!code-csharp[](../using-data-protection/samples/protectunprotect.cs?highlight=26,34,35,36,37,38,39,40)]

Пакет Microsoft. AspNetCore. в отношении защиты. абстракций содержит метод расширения `IServiceProvider.GetDataProtector` в качестве удобства для разработчиков. Он инкапсулируется как единая операция получения `IDataProtectionProvider` от поставщика службы и вызова `IDataProtectionProvider.CreateProtector` . В следующем примере демонстрируется его использование.

[!code-csharp[](./overview/samples/getdataprotector.cs?highlight=15)]

>[!TIP]
> Экземпляры `IDataProtectionProvider` и `IDataProtector` являются потокобезопасными для нескольких вызывающих объектов. Предполагается, что после того, как компонент получает ссылку на объект `IDataProtector` через вызов `CreateProtector` , он будет использовать эту ссылку для нескольких вызовов функций `Protect` и `Unprotect` . Вызов метода вызовет `Unprotect` исключение CryptographicException, если защищенные полезные данные не могут быть проверены или расшифрованы. Некоторым компонентам может потребоваться пропускать ошибки во время операций снятия защиты. компонент, считывающий проверку подлинности cookie , может обработать эту ошибку и обрабатывать запрос так, как если бы он имел вообще не cookie запрашивать ошибку. Компоненты, которые должны использовать это поведение, должны специально перехватывать CryptographicException, а не проглатывание все исключения.
