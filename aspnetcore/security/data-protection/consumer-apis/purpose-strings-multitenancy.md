---
title: Иерархия целей и мультитенантность в ASP.NET Core
author: rick-anderson
description: Сведения об иерархии строк назначения и использовании многофакторной связи, так как она относится к ASP.NET Core интерфейсам API защиты данных.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- ':::no-loc(appsettings.json):::'
- ':::no-loc(ASP.NET Core Identity):::'
- ':::no-loc(cookie):::'
- ':::no-loc(Cookie):::'
- ':::no-loc(Blazor):::'
- ':::no-loc(Blazor Server):::'
- ':::no-loc(Blazor WebAssembly):::'
- ':::no-loc(Identity):::'
- ":::no-loc(Let's Encrypt):::"
- ':::no-loc(Razor):::'
- ':::no-loc(SignalR):::'
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 84714cd852a3cbc7ff77d0fd0c88931536dead1a
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2020
ms.locfileid: "93052790"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="b8778-103">Иерархия целей и мультитенантность в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="b8778-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="b8778-104">Так как объект `IDataProtector` также неявно является `IDataProtectionProvider` , цели могут быть объединены в цепочку.</span><span class="sxs-lookup"><span data-stu-id="b8778-104">Since an `IDataProtector` is also implicitly an `IDataProtectionProvider`, purposes can be chained together.</span></span> <span data-ttu-id="b8778-105">В этом смысле `provider.CreateProtector([ "purpose1", "purpose2" ])` эквивалентно `provider.CreateProtector("purpose1").CreateProtector("purpose2")` .</span><span class="sxs-lookup"><span data-stu-id="b8778-105">In this sense, `provider.CreateProtector([ "purpose1", "purpose2" ])` is equivalent to `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span></span>

<span data-ttu-id="b8778-106">Это позволяет некоторым интересным иерархическим связям через систему защиты данных.</span><span class="sxs-lookup"><span data-stu-id="b8778-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="b8778-107">В предыдущем примере для [contoso. Messaging. секуремессаже](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose)компонент секуремессаже может вызываться `provider.CreateProtector("Contoso.Messaging.SecureMessage")` один раз перед передним планом и кэшировать результат в закрытое `_myProvider` поле.</span><span class="sxs-lookup"><span data-stu-id="b8778-107">In the earlier example of [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), the SecureMessage component can call `provider.CreateProtector("Contoso.Messaging.SecureMessage")` once up-front and cache the result into a private `_myProvider` field.</span></span> <span data-ttu-id="b8778-108">Затем можно создавать будущие предохранители с помощью вызовов `_myProvider.CreateProtector("User: username")` , а эти предохранители будут использоваться для защиты отдельных сообщений.</span><span class="sxs-lookup"><span data-stu-id="b8778-108">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="b8778-109">Это также можно сделать зеркально.</span><span class="sxs-lookup"><span data-stu-id="b8778-109">This can also be flipped.</span></span> <span data-ttu-id="b8778-110">Рассмотрим единое логическое приложение, в котором размещается несколько клиентов (это кажется разумным), и каждый клиент может быть настроен с помощью собственной системы проверки подлинности и управления состоянием.</span><span class="sxs-lookup"><span data-stu-id="b8778-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="b8778-111">Приложение-шаблон имеет одного главного поставщика и вызывает `provider.CreateProtector("Tenant 1")` и, `provider.CreateProtector("Tenant 2")` чтобы предоставить каждому клиенту собственный изолированный срез системы защиты данных.</span><span class="sxs-lookup"><span data-stu-id="b8778-111">The umbrella application has a single master provider, and it calls `provider.CreateProtector("Tenant 1")` and `provider.CreateProtector("Tenant 2")` to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="b8778-112">Клиенты могут получить собственные индивидуальные предохранители, основываясь на их собственных нуждах, но независимо от того, насколько сложно они попытаются, не могут создавать предохранители, которые конфликтуют с любым другим клиентом в системе.</span><span class="sxs-lookup"><span data-stu-id="b8778-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="b8778-113">Графическое представление представлено ниже.</span><span class="sxs-lookup"><span data-stu-id="b8778-113">Graphically, this is represented as below.</span></span>

![Многопользовательские цели](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="b8778-115">Предполагается, что приложение-клиент управляет тем, какие интерфейсы API доступны отдельным клиентам, и что клиенты не могут выполнять произвольный код на сервере.</span><span class="sxs-lookup"><span data-stu-id="b8778-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="b8778-116">Если клиент может выполнять произвольный код, он может выполнить закрытое отражение, чтобы разбить гарантии изоляции, или просто прочитать материал главного ключа напрямую и получить все необходимые им подразделы.</span><span class="sxs-lookup"><span data-stu-id="b8778-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="b8778-117">Система защиты данных в действительности использует сортировку по умолчанию в стандартной конфигурации.</span><span class="sxs-lookup"><span data-stu-id="b8778-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="b8778-118">По умолчанию материал основного ключа хранится в папке профиля пользователя учетной записи рабочего процесса (или в реестре для удостоверений пула приложений IIS).</span><span class="sxs-lookup"><span data-stu-id="b8778-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="b8778-119">Но на самом деле довольно часто используется одна учетная запись для запуска нескольких приложений, и поэтому все эти приложения будут совместно использовать главный материал для ключа.</span><span class="sxs-lookup"><span data-stu-id="b8778-119">But it's actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="b8778-120">Для решения этой проблемы система защиты данных автоматически вставляет уникальный идентификатор приложения в качестве первого элемента в цепочке общего назначения.</span><span class="sxs-lookup"><span data-stu-id="b8778-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="b8778-121">Это неявное назначение позволяет [изолировать отдельные приложения](xref:security/data-protection/configuration/overview#per-application-isolation) друг от друга, эффективно рассматривая каждое приложение как уникальный клиент в системе, и процесс создания предохранителя будет аналогичен приведенному выше изображению.</span><span class="sxs-lookup"><span data-stu-id="b8778-121">This implicit purpose serves to [isolate individual applications](xref:security/data-protection/configuration/overview#per-application-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
