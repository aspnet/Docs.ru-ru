---
title: Рекомендации по повышению производительности gRPC для ASP.NET Core
author: jamesnk
description: Ознакомьтесь с рекомендациями по созданию высокопроизводительных служб gRPC.
monikerRange: '>= aspnetcore-3.0'
ms.author: jamesnk
ms.date: 08/23/2020
no-loc:
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: grpc/performance
ms.openlocfilehash: f9cefa89ec6e533920b33223b34333f6ebe38428
ms.sourcegitcommit: 4df148cbbfae9ec8d377283ee71394944a284051
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/26/2020
ms.locfileid: "88876728"
---
# <a name="performance-best-practices-in-grpc-for-aspnet-core"></a>Рекомендации по повышению производительности gRPC для ASP.NET Core

Автор: [Джеймс Ньютон-Кинг (James Newton-King)](https://twitter.com/jamesnk)

Система gRPC предназначена для создания высокопроизводительных служб. В этом документе описывается, как обеспечить максимальную производительность gRPC.

## <a name="reuse-channel"></a>Повторное использование канала

При выполнении вызовов gRPC канал gRPC следует использовать повторно. Повторное использование канала позволяет мультиплексировать вызовы через существующее соединение HTTP/2.

Если для каждого вызова gRPC создается новый канал, то время, необходимое для его выполнения, может значительно возрасти. Каждый вызов потребует создания нескольких круговых путей по сети между клиентом и сервером для создания соединения HTTP/2:

1. открытие сокета;
2. установка TCP-соединения;
3. согласование TLS;
4. инициация соединения HTTP/2;
5. выполнение вызова gRPC.

Каналы можно безопасно использовать для нескольких вызовов gRPC.

* Клиенты gRPC создаются с помощью каналов. Клиенты gRPC являются облегченными объектами и не нуждаются в кэшировании или повторном использовании.
* Из одного канала можно создать несколько клиентов gRPC, включая различные типы клиентов.
* Канал и клиенты, созданные из канала, могут безопасно использоваться несколькими потоками.
* Клиенты, созданные из канала, могут выполнять несколько одновременных вызовов.

## <a name="connection-concurrency"></a>Параллелизм соединений

Обычно существует ограничение на [количество параллельных потоков (активных HTTP-запросов)](https://http2.github.io/http2-spec/#rfc.section.5.1.2) для одного соединения по HTTP/2. По умолчанию на большинстве серверов оно составляет 100 параллельных потоков.

Канал gRPC использует одно соединение HTTP/2, параллельные вызовы по которому мультиплексируются. Когда число активных вызовов достигает предельного числа потоков для соединения, дополнительные вызовы помещаются в очередь в клиенте. Вызовы в очереди ожидают завершения активных вызовов. Приложения с высокой нагрузкой или длительными потоковыми вызовами gRPC могут испытывать проблемы с производительностью, вызванные помещением вызовов в очередь из-за этого ограничения.

::: moniker range=">= aspnetcore-5.0"

В .NET 5 появилось свойство `SocketsHttpHandler.EnableMultipleHttp2Connections`. Если ему присвоено значение `true`, то при достижении предельного числа параллельных потоков канал создает дополнительные соединения HTTP/2. При создании `GrpcChannel` его внутренний обработчик `SocketsHttpHandler` автоматически настраивается так, чтобы создавались дополнительные соединения HTTP/2. Если приложение настраивает собственный обработчик, рекомендуется присвоить свойству `EnableMultipleHttp2Connections` значение `true`.

```csharp
var channel = GrpcChannel.ForAddress("https://localhost", new GrpcChannelOptions
{
    HttpHandler = new SocketsHttpHandler
    {
        EnableMultipleHttp2Connections = true,

        // ...configure other handler settings
    }
});
```

::: moniker-end

Для приложений .NET Core 3.1 существует несколько обходных путей.

* Создайте отдельные каналы gRPC для частей приложения с высокой нагрузкой. Например, служба gRPC `Logger` может испытывать высокую нагрузку. Используйте отдельный канал для создания `LoggerClient` в приложении.
* Используйте пул каналов gRPC, например создайте их список. `Random` используется для выбора канала из списка каждый раз, когда требуется канал gRPC. Использование `Random` позволяет случайным образом распределять вызовы между несколькими соединениями.

> [!IMPORTANT]
> Еще один способ решить эту проблему — увеличить максимальное число параллельных потоков на сервере. В Kestrel оно настраивается с помощью <xref:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.MaxStreamsPerConnection>.
>
> Увеличивать максимальное число параллельных потоков не рекомендуется. Слишком большое число потоков в одном соединении HTTP/2 вызывает новые проблемы с производительностью.
>
> * Возникает состязание между потоками, пытающимися выполнить запись через соединение.
> * Потеря пакетов, передаваемых через соединение, приводит к блокировке всех вызовов на уровне TCP.

::: moniker range=">= aspnetcore-5.0"

## <a name="keep-alive-pings"></a>Пакеты проверки активности

Пакеты проверки активности могут использоваться для поддержания соединений HTTP/2 в активном состоянии в периоды бездействия. Готовность соединения HTTP/2 на момент возобновления работы приложения позволяет быстро выполнять первые вызовы gRPC без задержки, вызванной повторным установлением соединения.

Пакеты проверки активности настраиваются в <xref:System.Net.Http.SocketsHttpHandler>.

```csharp
var handler = new SocketsHttpHandler
{
    PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan,
    KeepAlivePingDelay = TimeSpan.FromSeconds(60),
    KeepAlivePingTimeout = TimeSpan.FromSeconds(30),
    EnableMultipleHttp2Connections = true
};

var channel = GrpcChannel.ForAddress("https://localhost:5001", new GrpcChannelOptions
{
    HttpHandler = handler
});
```

Приведенный выше код настраивает канал, который отправляет пакет проверки активности на сервер каждые 60 секунд в периоды бездействия. Проверка активности гарантирует, что сервер и все используемые прокси-серверы не закроют соединение из-за бездействия.

::: moniker-end

## <a name="streaming"></a>Потоковая передача

В высокопроизводительных сценариях вместо отдельных вызовов gRPC может использоваться двунаправленная потоковая передача gRPC. После запуска двунаправленного потока потоковая передача сообщений в обе стороны происходит быстрее, чем отправка сообщений для нескольких отдельных вызовов gRPC. Потоковые сообщения отправляются в виде данных существующего запроса HTTP/2, благодаря чему устраняются издержки на создание запроса HTTP/2 для каждого отдельного вызова.

Пример службы:

```csharp
public override async Task SayHello(IAsyncStreamReader<HelloRequest> requestStream,
    IServerStreamWriter<HelloReply> responseStream, ServerCallContext context)
{
    await foreach (var request in requestStream.ReadAllAsync())
    {
        var helloReply = new HelloReply { Message = "Hello " + request.Name };

        await responseStream.WriteAsync(helloReply);
    }
}
```

Пример клиента:

```csharp
var client = new Greet.GreeterClient(channel);
using var call = client.SayHello();

Console.WriteLine("Type a name then press enter.");
while (true)
{
    var text = Console.ReadLine();

    // Send and receive messages over the stream
    await call.RequestStream.WriteAsync(new HelloRequest { Name = text });
    await call.ResponseStream.MoveNext();

    Console.WriteLine($"Greeting: {call.ResponseStream.Current.Message}");
}
```

Замена отдельных вызовов на двунаправленную потоковую передачу для повышения производительности — сложный в реализации метод, который не подходит во многих ситуациях.

Использовать потоковые вызовы рекомендуется в указанных ниже случаях.

1. Требуется высокая пропускная способность или низкая задержка.
2. gRPC и HTTP/2 были определены как узкие места производительности.
3. Рабочая роль клиента регулярно отправляет или получает сообщения с помощью службы gRPC.

Обратите внимание на дополнительные сложности и ограничения, связанные с использованием потоковых вызовов вместо отдельных.

1. Поток может быть прерван службой или ошибкой соединения. Для перезапуска потока при возникновении ошибки требуется логика.
2. `RequestStream.WriteAsync` небезопасно использовать в режиме многопоточности. В поток за раз можно записать только одно сообщение. Для отправки сообщений из нескольких потоков требуется очередь производителя или потребителя, например <xref:System.Threading.Channels.Channel%601>, для маршалирования сообщений.
3. Метод потоковой передачи gRPC ограничен получением и отправкой сообщений одного типа. Например, `rpc StreamingCall(stream RequestMessage) returns (stream ResponseMessage)` получает `RequestMessage` и отправляет `ResponseMessage`. Поддержка неизвестных или условных сообщений в protobuf благодаря `Any` и `oneof` позволяет обойти это ограничение.
