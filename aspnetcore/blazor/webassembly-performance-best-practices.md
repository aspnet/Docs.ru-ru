---
title: Рекомендации по повышению производительности ASP.NET Core Blazor WebAssembly
author: pranavkm
description: Советы по повышению производительности приложений ASP.NET Core Blazor WebAssembly и избежанию распространенных проблем с производительностью.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc, devx-track-js
ms.date: 10/09/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: blazor/webassembly-performance-best-practices
ms.openlocfilehash: 1860a36ba4122fb39ca92797da9a44b282afa793
ms.sourcegitcommit: 1166b0ff3828418559510c661e8240e5c5717bb7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/12/2021
ms.locfileid: "100280651"
---
# <a name="aspnet-core-blazor-webassembly-performance-best-practices"></a>Рекомендации по повышению производительности ASP.NET Core Blazor WebAssembly

Среда Blazor WebAssembly тщательно спроектирована и оптимизирована для обеспечения высокой производительности в наиболее часто применимых сценариях пользовательского интерфейса в приложениях. Но качество результатов зависит еще и от того, насколько правильно разработчики используют шаблоны и функции. Давайте рассмотрим следующие аспекты.

* **Пропускная способность среды выполнения.** Код .NET выполняется в интерпретаторе в среде выполнения WebAssembly, что ограничивает пропускную способность ЦП. Для ресурсоемких сценариев стоит применить в приложении [оптимизацию скорости отрисовки](#optimize-rendering-speed).
* **Время запуска.** Приложение передает среду выполнения .NET в браузер, поэтому важно использовать функции, которые позволяют [уменьшить размер скачиваемого приложения](#minimize-app-download-size).

## <a name="optimize-rendering-speed"></a>Оптимизация скорости отрисовки

В следующих разделах собраны рекомендации по уменьшению рабочей нагрузки для отрисовки и повышению скорости реагирования пользовательского интерфейса. Применение этих советов часто позволяет ускорить отрисовку пользовательского интерфейса *в десять и более раз*.

### <a name="avoid-unnecessary-rendering-of-component-subtrees"></a>Избегайте ненужной отрисовки поддеревьев компонентов

В среде выполнения все компоненты занимают определенное место в иерархии. Корневой компонент содержит дочерние компоненты. Каждый из этих дочерних элементов может содержать собственные дочерние компоненты, и так далее. При возникновении события, например при нажатии кнопки, Blazor выбирает компоненты для визуализации по следующему алгоритму:

1. Возникшее событие отправляется в тот компонент, который создал обработчик такого события. После выполнения обработчика событий соответствующий компонент повторно отрисовывается.
1. При каждой повторной отрисовке компонент предоставляет новую копию значений параметров каждому из своих дочерних компонентов.
1. Получив новый набор значений параметров, каждый компонент самостоятельно решает, нужно ли выполнять повторную отрисовку. По умолчанию это происходит в том случае, если значения параметров могли измениться (например, если они являются изменяемыми объектами).

И далее два последних шага рекурсивно повторяются для всех компонентов вниз по иерархии. Во многих случаях это приводит к перерисовке всего дерева. Это означает, что события для компонентов высокого уровня могут приводить к высоким затратам на перерисовку всех компонентов вниз по иерархии, начиная с целевого.

Прервать такой процесс и избежать рекурсивной перерисовки всех компонентов в поддереве можно одним из следующих способов:

* Присвойте всем параметрам каждого компонента примитивные неизменяемые типы (`string`, `int`, `bool`, `DateTime` и т. п.). В этом случае встроенная логика отслеживания изменений будет пропускать перерисовку, когда значения параметров не изменились явным образом. Если для отрисовки дочернего компонента используется `<Customer CustomerId="@item.CustomerId" />`, где значение `CustomerId` имеет тип `int`, то он будет перерисовываться только при изменении `item.CustomerId`.
* Если вы не можете обойтись только примитивными значениями параметров (например, вам нужны пользовательские типы моделей, обратные вызовы событий или значения <xref:Microsoft.AspNetCore.Components.RenderFragment>), можно переопределить <xref:Microsoft.AspNetCore.Components.ComponentBase.ShouldRender%2A> для принятия собственного решения об отрисовке при изменениях, как описано в разделе об [использовании `ShouldRender`](#use-of-shouldrender).

Пропуская перерисовку целых поддеревьев, вы сможете устранить почти все затраты на отрисовку при возникновении событий.

Возможно, вы захотите исключить конкретные дочерние компоненты, чтобы пропустить перерисовку соответствующей ветви пользовательского интерфейса. Это допустимый способ снижения затрат на отрисовку родительского компонента.

#### <a name="use-of-shouldrender"></a>Использование `ShouldRender`

При создании компонента, который используется только в пользовательском интерфейсе и не изменяется после первоначальной отрисовки (независимо от значений параметров), настройте метод <xref:Microsoft.AspNetCore.Components.ComponentBase.ShouldRender%2A> так, чтобы он возвращал значение `false`:

```razor
@code {
    protected override bool ShouldRender() => false;
}
```

Если перерисовка компонента требуется только при некоторых изменениях значений его параметров, вы можете использовать скрытые поля для отслеживания важной информации с целью обнаружения изменений. В следующем примере значение `shouldRender` вычисляется по наличию таких изменений или преобразований, которые требуют перерисовки. `prevOutboundFlightId` и `prevInboundFlightId` отслеживают сведения, которые определяют необходимость следующего обновления.

```razor
@code {
    [Parameter]
    public FlightInfo OutboundFlight { get; set; }
    
    [Parameter]
    public FlightInfo InboundFlight { get; set; }

    private int prevOutboundFlightId;
    private int prevInboundFlightId;
    private bool shouldRender;

    protected override void OnParametersSet()
    {
        shouldRender = OutboundFlight.FlightId != prevOutboundFlightId
            || InboundFlight.FlightId != prevInboundFlightId;

        prevOutboundFlightId = OutboundFlight.FlightId;
        prevInboundFlightId = InboundFlight.FlightId;
    }

    protected override bool ShouldRender() => shouldRender;

    // Note that 
}
```

В приведенном выше коде обработчик событий может установить для `shouldRender` значение `true`, чтобы выполнить перерисовку компонента после обработки события.

Для большинства компонентов такой уровень управления вручную не требуется. Достаточно лишь обеспечить пропуск отрисовки для тех поддеревьев, отрисовка которых особенно трудоемка и может приводить к задержкам в пользовательском интерфейсе.

Для получения дополнительной информации см. <xref:blazor/components/lifecycle>.

::: moniker range=">= aspnetcore-5.0"

### <a name="virtualization"></a>Виртуализация

Если в некотором цикле выполняется отрисовка значительной части пользовательского интерфейса, например списка или сетки с тысячами записей, само по себе количество операций может приводить к задержке в отрисовке пользовательского интерфейса и ухудшению взаимодействия с пользователем. Учитывая, что пользователь одновременно без прокрутки видит лишь небольшое количество таких элементов, зачастую излишне тратить время на отрисовку тех элементов, которые пока не видны.

Чтобы решить эту проблему, в Blazor предоставляется встроенный компонент `Virtualize`, который эмулирует поведение отображения и прокрутки для произвольно большого списка, фактически отображая только те из них, которые попадают в текущее окно просмотра с учетом прокрутки. Например, вы сможете создать в приложении список со 100 000 записей, тратя ресурсы отрисовки только на те 20 элементов, которые видимы в конкретный момент времени. Использование компонента `Virtualize` позволяет повысить производительность пользовательского интерфейса в несколько раз.

Для получения дополнительной информации см. <xref:blazor/components/virtualization>.

::: moniker-end

### <a name="create-lightweight-optimized-components"></a>Создание простых и оптимизированных компонентов

Для большинства компонентов Blazor не требуются агрессивные действия по оптимизации. Это связано с тем, что большинство компонентов присутствуют в пользовательском интерфейсе в малом количестве копий и не отрисовываются с высокой частотой. Например, компоненты `@page` и компоненты, представляющие высокоуровневые элементы пользовательского интерфейса (диалоговые окна, формы и т. п.), обычно отображаются только в одно экземпляре и отрисовываются только в ответ на жест пользователя. Такие компоненты не создают высокой нагрузки на подсистему отрисовки, что позволяет свободно использовать любые сочетания функций платформы, не беспокоясь о производительности при отрисовке.

Но есть и другие, не менее распространенные сценарии, в которых компоненты создаются в большом количестве экземпляров. Пример:

* Большие вложенные формы могут иметь сотни полей для ввода, меток и других элементов.
* Сетки могут содержать тысячи ячеек.
* Точечные диаграммы могут содержать миллионы точек данных.

Если каждая такая единица будет существовать в виде отдельного экземпляра компонента, их количество приведет к критической нагрузке на производительность отрисовки. В этом разделе собраны рекомендации по упрощению систем с такими компонентами, которые позволят сохранить скорость работы и реагирования пользовательского интерфейса.

#### <a name="avoid-thousands-of-component-instances"></a>Не создавайте тысячи экземпляров компонентов

Каждый компонент является обособленным объектом, который можно отрисовывать отдельно, независимо от его родительских и дочерних элементов. Правильный выбор способа для структурирования пользовательского интерфейса в иерархии компонентов позволяет контролировать степень детализации для отрисовки пользовательского интерфейса. Это может по-разному влиять на производительность.

* Разделяя пользовательский интерфейс на большое число компонентов, вы уменьшаете объем перерисовки при возникновении событий пользовательского интерфейса. Например, когда пользователь нажимает кнопку в строке таблицы, можно вместо всей страницы или таблицы повторно отрисовать только одну строку.
* Но каждый дополнительный компонент требует дополнительный объем памяти и времени ЦП для поддержки индивидуального состояния и жизненного цикла визуализации.

При настройке производительности Blazor WebAssembly в .NET 5 мы пришли к выводу, что на отрисовку каждого экземпляра компонента требуется около 0,06 мс. Расчеты проводились для простого компонента, который принимает три параметра, при выполнении на типичном ноутбуке. На внутреннем уровне издержки связаны в первую очередь с извлечением из словарей состояния для каждого компонента, а также с передачей и получением параметров. Умножая это значение на число компонентов, легко заметить, что 2000 экземпляров компонентов увеличат время отрисовки на 0,12 секунд, что для пользователя означает уже заметное замедление пользовательского интерфейса.

Вы можете сделать компоненты более простыми, чтобы поддерживать большее их число, но часто лучшим подходом будет уменьшение количества компонентов. В следующих разделах мы опишем оба подхода.

##### <a name="inline-child-components-into-their-parents"></a>Дочерние компоненты, встроенные в родительские

Давайте рассмотрим такой компонент, который отрисовывает серию дочерних компонентов:

```razor
<div class="chat">
    @foreach (var message in messages)
    {
        <ChatMessageDisplay Message="@message" />
    }
</div>
```

В приведенном выше примере кода компонент `<ChatMessageDisplay>` определяется в файле `ChatMessageDisplay.razor` следующего содержания:

```razor
<div class="chat-message">
    <span class="author">@Message.Author</span>
    <span class="text">@Message.Text</span>
</div>

@code {
    [Parameter]
    public ChatMessage Message { get; set; }
}
```

Представленный выше пример хорошо работает, пока не придется отобразить одновременно несколько тысяч сообщений. Чтобы отобразить все эти сообщения, мы можем *отказаться* от создания отдельных компонентов `ChatMessageDisplay`. Вместо этого мы встроим этот компонент отрисовки напрямую в родительский компонент:

```razor
<div class="chat">
    @foreach (var message in messages)
    {
        <div class="chat-message">
            <span class="author">@message.Author</span>
            <span class="text">@message.Text</span>
        </div>
    }
</div>
```

Так мы избежим накладных расходов на отрисовку большого числа дочерних компонентов, но зато потеряем возможность отрисовывать их независимо друг от друга.

##### <a name="define-reusable-renderfragments-in-code"></a>Определение повторно используемого делегата `RenderFragments` в коде

Возможно, вы создаете дочерние компоненты просто для того, чтобы повторно использовать логику отрисовки. В этом сценарии есть возможность повторно использовать логику отрисовки без объявления фактических компонентов. В блоке `@code` любого компонента объявите <xref:Microsoft.AspNetCore.Components.RenderFragment>, который возвращает пользовательский интерфейс и может вызываться из любого места:

```razor
<h1>Hello, world!</h1>

@RenderWelcomeInfo

@code {
    private RenderFragment RenderWelcomeInfo = __builder =>
    {
        <div>
            <p>Welcome to your new app!</p>

            <SurveyPrompt Title="How is Blazor working for you?" />
        </div>
    };
}
```

Как показано в предыдущем примере, компоненты могут создавать разметку как в коде блока `@code`, так и вне его. Такой подход использует объявление делегата <xref:Microsoft.AspNetCore.Components.RenderFragment>, который можно отрисовывать в выходном потоке отрисовки компонента, в том числе из нескольких разных мест. Важно, чтобы этот делегат принимал параметр с именем `__builder` и типом <xref:Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder>, на основе которого компилятор Razor будет создавать инструкции отрисовки.

Если вы хотите использовать его в нескольких компонентах, можно объявить элемент `public static`:

```razor
public static RenderFragment SayHello = __builder =>
{
    <h1>Hello!</h1>
};
```

Теперь его можно вызывать из любого компонента, даже не являющегося родственным. Такая методика удобна для создания библиотек повторно используемых фрагментов кода разметки, которые позволяют избавиться от накладных расходов на создание каждого компонента.

Делегаты <xref:Microsoft.AspNetCore.Components.RenderFragment> могут принимать параметры. Так вы можете создать структуру, эквивалентную компоненту `ChatMessageDisplay` из предыдущего примера:

```razor
<div class="chat">
    @foreach (var message in messages)
    {
        @ChatMessageDisplay(message)
    }
</div>

@code {
    private RenderFragment<ChatMessage> ChatMessageDisplay = message => __builder =>
    {
        <div class="chat-message">
            <span class="author">@message.Author</span>
            <span class="text">@message.Text</span>
        </div>
    };
}
```

Такой подход позволяет повторно использовать логику отрисовки без дополнительных затрат на компоненты. Но зато здесь невозможно независимо обновлять поддерево пользовательского интерфейса или пропускать визуализацию этого поддерева при отрисовке родительского элемента, так как мы убрали границу между компонентами.

Для нестатического поля, метода или свойства, на которые не может ссылаться инициализатор поля, например `TitleTemplate` в следующем примере, используйте свойство вместо поля для <xref:Microsoft.AspNetCore.Components.RenderFragment>:

```csharp
protected RenderFragment DisplayTitle => __builder =>
{
    <div>
        @TitleTemplate
    </div>   
};
```

#### <a name="dont-receive-too-many-parameters"></a>Не принимайте слишком много параметров

Если компонент повторяется очень часто, например сотни или тысячи раз, важно помнить о накладных расходах на передачу и получение каждого параметра.

Маловероятно, что большое число параметров само по себе ухудшит производительность, но оно может усложнить ситуацию при наличии других проблем. Для компонента `<TableCell>`, который отображается 1000 раз в сетке, каждый дополнительный передаваемый параметр увеличивает время отрисовки примерно на 15 мс. Если каждая ячейка принимает 10 параметров, то передача параметров займет около 150 мс на каждый компонент, то есть 150 000 мс (150 секунд) в целом, что сделает пользовательский интерфейс очень медленным.

Чтобы уменьшить эту нагрузку, объедините несколько параметров в пакет с помощью пользовательских классов. Например, компонент `<TableCell>` может принимать параметры так:

```razor
@typeparam TItem

...

@code {
    [Parameter]
    public TItem Data { get; set; }
    
    [Parameter]
    public GridOptions Options { get; set; }
}
```

В предыдущем примере значение `Data` будет разным для каждой ячейки, но `Options` является общим для всех. Разумеется, еще лучше будет отказаться от компонента `<TableCell>`, встроив его логику в родительский компонент.

#### <a name="ensure-cascading-parameters-are-fixed"></a>Сделайте все каскадные параметры фиксированными

Компонент `<CascadingValue>` принимает необязательный параметр с именем `IsFixed`.

* Если значение `IsFixed` равно `false` (вариант по умолчанию), то каждый получатель каскадного значения настраивает подписку для получения уведомлений об изменениях. В этом примере каждый `[CascadingParameter]` обойдется **значительно дороже** обычного `[Parameter]` из-за затрат на отслеживания подписки.
* Если значение `IsFixed` равно `true` (например, `<CascadingValue Value="@someValue" IsFixed="true">`), то получатели получают начальное значение, но *не настраивают* подписку для получения обновлений. Тогда каждый элемент `[CascadingParameter]` будет достаточно легким и **не дороже**, чем обычный `[Parameter]`.

Старайтесь везде, где возможно, использовать `IsFixed="true"` в каскадных значениях. Это не вызовет затруднений, если передаваемое значение не меняется со временем. В типичной ситуации, когда компонент передает `this` в виде каскадного значения, следует использовать `IsFixed="true"`:

```razor
<CascadingValue Value="this" IsFixed="true">
    <SomeOtherComponents>
</CascadingValue>
```

Это даст огромную разницу в производительности, если большое число других компонентов получают это каскадное значение. Для получения дополнительной информации см. <xref:blazor/components/cascading-values-and-parameters>.

#### <a name="avoid-attribute-splatting-with-captureunmatchedvalues"></a>Не используйте сплаттинг атрибутов с `CaptureUnmatchedValues`

Компоненты могут получать "несопоставленные" значения параметров с помощью флага <xref:Microsoft.AspNetCore.Components.ParameterAttribute.CaptureUnmatchedValues>:

```razor
<div @attributes="OtherAttributes">...</div>

@code {
    [Parameter(CaptureUnmatchedValues = true)]
    public IDictionary<string, object> OtherAttributes { get; set; }
}
```

Такой подход позволяет передать элементу произвольные дополнительные атрибуты. Но этот подход довольно дорогой, поскольку отрисовщик будет выполнять следующие действия:

* сопоставление всех полученных параметров с набором известных параметров для построения словаря;
* отслеживание копий одного атрибута, которые переопределяют друг друга.

Вы можете использовать <xref:Microsoft.AspNetCore.Components.ParameterAttribute.CaptureUnmatchedValues> для тех компонентов, которые не создают критической нагрузки на производительность, например редко повторяются. Но для компонентов с большим масштабом отрисовки, таких как элементы большого списка или ячейки сетки, избегайте сплаттинга атрибутов.

Для получения дополнительной информации см. <xref:blazor/components/index#attribute-splatting-and-arbitrary-parameters>.

#### <a name="implement-setparametersasync-manually"></a>Реализуйте `SetParametersAsync` вручную

Одним из основных аспектов, влияющих на затраты отрисовки каждого компонента, является запись значений входящих параметров в свойства `[Parameter]`. Для них отрисовщик использует отражение. Этот механизм имеет некоторую оптимизацию, но отсутствие поддержки JIT в среде выполнения WebAssembly налагает определенные ограничения.

В некоторых крайних случаях следует избегать отражений и вручную реализовать собственную логику настройки параметров. Это может уместно в следующих случаях:

* у вас есть компонент, который отображается чрезвычайно часто (например, существуют сотни или тысячи его копий в пользовательском интерфейсе);
* компонент принимает много параметров;
* вы заметили, что издержки на получение параметров заметно влияют на скорость реагирования пользовательского интерфейса.

В таких случаях вы можете переопределить виртуальный метод <xref:Microsoft.AspNetCore.Components.ComponentBase.SetParametersAsync%2A> компонента и реализовать собственную логику для конкретного компонента. Следующий пример намеренно создан так, чтобы избежать поиска в словаре:

```razor
@code {
    [Parameter]
    public int MessageId { get; set; }

    [Parameter]
    public string Text { get; set; }

    [Parameter]
    public EventCallback<string> TextChanged { get; set; }

    [Parameter]
    public Theme CurrentTheme { get; set; }

    public override Task SetParametersAsync(ParameterView parameters)
    {
        foreach (var parameter in parameters)
        {
            switch (parameter.Name)
            {
                case nameof(MessageId):
                    MessageId = (int)parameter.Value;
                    break;
                case nameof(Text):
                    Text = (string)parameter.Value;
                    break;
                case nameof(TextChanged):
                    TextChanged = (EventCallback<string>)parameter.Value;
                    break;
                case nameof(CurrentTheme):
                    CurrentTheme = (Theme)parameter.Value;
                    break;
                default:
                    throw new ArgumentException($"Unknown parameter: {parameter.Name}");
            }
        }

        return base.SetParametersAsync(ParameterView.Empty);
    }
}
```

В приведенном выше коде возвращение базового класса <xref:Microsoft.AspNetCore.Components.ComponentBase.SetParametersAsync%2A> запускает обычные методы жизненного цикла без повторного назначения параметров.

Как мы видим в приведенном выше коде, переопределение <xref:Microsoft.AspNetCore.Components.ComponentBase.SetParametersAsync%2A> и предоставление пользовательской логики достаточно сложны и трудоемки, поэтому мы не рекомендуем использовать этот подход в общем случае. В исключительных ситуациях он может повысить производительность отрисовки на 20–25 %, но его стоит применять только в перечисленных выше сценариях.

### <a name="dont-trigger-events-too-rapidly"></a>Не активируйте события слишком часто

Некоторые события браузера происходят очень часто, например `onmousemove` и `onscroll` могут запускаться десятки или даже сотни раз в секунду. В большинстве случаев вам не нужно так часто обновлять интерфейс. Такое частое обновление может снижать скорость реагирования пользовательского интерфейса или создавать чрезмерную нагрузку на ЦП.

Вместо системных событий `@onmousemove` или `@onscroll` вам лучше применить механизм взаимодействия JS, чтобы зарегистрировать более редко вызываемый обратный вызов. Например, следующий компонент `MyComponent.razor` отображает текущее положение мыши только один раз в каждые 500 мс:

```razor
@inject IJSRuntime JS
@implements IDisposable

<h1>@message</h1>

<div @ref="myMouseMoveElement" style="border:1px dashed red;height:200px;">
    Move mouse here
</div>

@code {
    ElementReference myMouseMoveElement;
    DotNetObjectReference<MyComponent> selfReference;
    private string message = "Move the mouse in the box";

    [JSInvokable]
    public void HandleMouseMove(int x, int y)
    {
        message = $"Mouse move at {x}, {y}";
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            selfReference = DotNetObjectReference.Create(this);
            var minInterval = 500; // Only notify every 500 ms
            await JS.InvokeVoidAsync("onThrottledMouseMove", 
                myMouseMoveElement, selfReference, minInterval);
        }
    }

    public void Dispose() => selfReference?.Dispose();
}
```

Соответствующий код JavaScript, который можно поместить на страницу `index.html` или загрузить в виде модуля ES6, регистрирует прослушиватель событий DOM. В нашем примере прослушиватель событий использует [функцию Lodash `throttle`](https://lodash.com/docs/4.17.15#throttle), чтобы ограничить частоту вызовов:

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js"></script>
<script>
  function onThrottledMouseMove(elem, component, interval) {
    elem.addEventListener('mousemove', _.throttle(e => {
      component.invokeMethodAsync('HandleMouseMove', e.offsetX, e.offsetY);
    }, interval));
  }
</script>
```

Этот подход даст еще более заметный результат для Blazor Server, так как каждый вызов события требует доставки сообщения по сети. Для Blazor WebAssembly это полезно тем, что может значительно снизить объем работы по отрисовке.

## <a name="optimize-javascript-interop-speed"></a>Оптимизируйте скорость взаимодействия в JavaScript

Передача вызовов между .NET и JavaScript требует дополнительных затрат по нескольким причинам:

* все вызовы по умолчанию асинхронны;
* все параметры и возвращаемые значения по умолчанию сериализуются в формат JSON. Это нужно для того, чтобы создать простой для понимания механизм преобразования типов между .NET и JavaScript.

Кроме того, в Blazor Server эти вызовы передаются по сети.

### <a name="avoid-excessively-fine-grained-calls"></a>Не используйте чрезмерно подробные вызовы

Поскольку каждый вызов влечет за собой накладные расходы, будет полезно снизить их количество. Давайте рассмотрим следующий код, который сохраняет коллекцию элементов в хранилище `localStorage` браузера:

```csharp
private async Task StoreAllInLocalStorage(IEnumerable<TodoItem> items)
{
    foreach (var item in items)
    {
        await JS.InvokeVoidAsync("localStorage.setItem", item.Id, 
            JsonSerializer.Serialize(item));
    }
}
```

В предшествующем примере для каждого элемента создается отдельный вызов для взаимодействия с JS. Вместо этого можно ограничить взаимодействие с JS пределами одного вызова:

```csharp
private async Task StoreAllInLocalStorage(IEnumerable<TodoItem> items)
{
    await JS.InvokeVoidAsync("storeAllInLocalStorage", items);
}
```

Ниже определяется соответствующая функция JavaScript:

```javascript
function storeAllInLocalStorage(items) {
  items.forEach(item => {
    localStorage.setItem(item.id, JSON.stringify(item));
  });
}
```

Для Blazor WebAssembly это важно лишь при очень большом числе вызовов для взаимодействия с JS.

### <a name="consider-making-synchronous-calls"></a>Старайтесь использовать синхронные вызовы

Вызовы для взаимодействия с JavaScript по умолчанию асинхронны, независимо от поддержки синхронности в вызываемом коде. Это нужно для совместимости всех компонентов как с Blazor WebAssembly, так и с Blazor Server. Дело в том, что в Blazor Server все вызовы для взаимодействия с JavaScript передаются через сетевое подключение, поэтому они должны быть асинхронными.

Если же вам точно известно, что приложение будет выполняться только на Blazor WebAssembly, вы можете переключиться на использование синхронных вызовов для взаимодействия с JavaScript. Они создают чуть меньше нагрузки, чем асинхронные вызовы, и снижают число циклов отрисовки благодаря отсутствию промежуточного состояния на время ожидания результатов.

Чтобы выполнить синхронный вызов из .NET к JavaScript, приведите <xref:Microsoft.JSInterop.IJSRuntime> к <xref:Microsoft.JSInterop.IJSInProcessRuntime>:

```razor
@inject IJSRuntime JS

...

@code {
    protected override void HandleSomeEvent()
    {
        var jsInProcess = (IJSInProcessRuntime)JS;
        var value = jsInProcess.Invoke<string>("javascriptFunctionIdentifier");
    }
}
```

::: moniker range=">= aspnetcore-5.0"

При работе с `IJSObjectReference` синхронный вызов выполняется приведением к `IJSInProcessObjectReference`.

::: moniker-end

Чтобы выполнить синхронный вызов из JavaScript к .NET, используйте `DotNet.invokeMethod` вместо `DotNet.invokeMethodAsync`.

Синхронные вызовы возможны, если соблюдаются следующие условия:

* приложение работает только на Blazor WebAssembly, но не на Blazor Server;
* вызываемся функция возвращает значение синхронным способом (то есть не является методом `async` и не возвращает <xref:System.Threading.Tasks.Task> в .NET или `Promise` в JavaScript).

Для получения дополнительной информации см. <xref:blazor/call-javascript-from-dotnet>.

::: moniker range=">= aspnetcore-5.0"
 
### <a name="consider-making-unmarshalled-calls"></a>Старайтесь использовать демаршалированные вызовы

При работе в Blazor WebAssembly есть возможность выполнять демаршалированные вызовы из .NET к JavaScript. Так называются синхронные вызовы, которые не используют сериализацию в JSON для аргументов или возвращаемых значений. Все аспекты управления памятью и преобразования представлений для .NET и JavaScript остаются на усмотрение разработчика.

> [!WARNING]
> Хотя использование `IJSUnmarshalledRuntime` обеспечивает наименьшие издержки по сравнению с другими подходами к взаимодействию с JS, интерфейсы API JavaScript, необходимые для взаимодействия с этими интерфейсами API, в настоящее время не документированы и могут подвернуться критическим изменениям в будущих выпусках.

```javascript
function jsInteropCall() {
    return BINDING.js_to_mono_obj("Hello world");
}
```

```razor
@inject IJSRuntime JS

@code {
    protected override void OnInitialized()
    {
        var unmarshalledJs = (IJSUnmarshalledRuntime)JS;
        var value = unmarshalledJs.InvokeUnmarshalled<string>("jsInteropCall");
    }
}
```

::: moniker-end

## <a name="minimize-app-download-size"></a>Уменьшайте размер скачиваемого приложения

::: moniker range=">= aspnetcore-5.0"

### <a name="intermediate-language-il-trimming"></a>Обрезка промежуточного языка (IL)

Обрезка неиспользуемых сборок в приложении Blazor WebAssembly уменьшает размер приложения за счет удаления неиспользуемого кода в двоичных файлах приложения. Для получения дополнительной информации см. <xref:blazor/host-and-deploy/configure-trimmer>.

::: moniker-end

::: moniker range="< aspnetcore-5.0"

### <a name="intermediate-language-il-linking"></a>Компоновка промежуточного языка (IL)

[Компоновка приложения Blazor WebAssembly](xref:blazor/host-and-deploy/configure-linker) уменьшает размер приложения за счет удаления неиспользуемого кода в двоичных файлах приложения. По умолчанию компоновщик промежуточного языка (IL) включается только при сборке в конфигурации `Release`. Чтобы воспользоваться этой возможностью, опубликуйте приложение для развертывания с помощью команды [`dotnet publish`](/dotnet/core/tools/dotnet-publish) с параметром [-c|--configuration](/dotnet/core/tools/dotnet-publish#options), имеющим значение `Release`:

```dotnetcli
dotnet publish -c Release
```

::: moniker-end

### <a name="use-systemtextjson"></a>Использование System.Text.Json

Реализация взаимодействия с JS в Blazor основана на <xref:System.Text.Json>, высокопроизводительной библиотеке сериализации JSON, занимающей мало места в памяти. Использование <xref:System.Text.Json> не приводит к увеличению размера полезных данных в приложении, в отличие от добавления одной или нескольких альтернативных библиотек JSON.

Руководство по миграции см. в статье [Миграция с `Newtonsoft.Json` на `System.Text.Json`](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="lazy-load-assemblies"></a>Сборки с отложенной загрузкой

Загрузка сборок во время выполнения на том этапе, когда они необходимы для маршрута. Для получения дополнительной информации см. <xref:blazor/webassembly-lazy-load-assemblies>.

### <a name="compression"></a>Сжатие

При публикации приложения Blazor WebAssembly выходные данные статически сжимаются, чтобы уменьшить размер приложения и исключить издержки на сжатие среды выполнения. Blazor использует сервер для согласования содержимого и предоставления статически сжатых файлов.

После развертывания приложения убедитесь в том, что приложение предоставляет сжатые файлы. В браузере откройте вкладку "Сеть" в Средствах для разработчиков и убедитесь в том, что файлы предоставляются с `Content-Encoding: br` или `Content-Encoding: gz`. Если узел не предоставляет сжатые файлы, выполните инструкции в разделе <xref:blazor/host-and-deploy/webassembly#compression>.

### <a name="disable-unused-features"></a>Отключение неиспользуемых функций

Среда выполнения Blazor WebAssembly включает в себя следующие функции .NET, которые можно отключить, если они не требуются приложению, для уменьшения размера полезных данных:

* Для обеспечения правильности сведений о часовом поясе включается файл данных. Если приложению не нужна эта функция, ее можно отключить, присвоив свойству MSBuild `BlazorEnableTimeZoneSupport` в файле проекта приложения значение `false`:

  ```xml
  <PropertyGroup>
    <BlazorEnableTimeZoneSupport>false</BlazorEnableTimeZoneSupport>
  </PropertyGroup>
  ```

::: moniker range=">= aspnetcore-5.0"

* По умолчанию Blazor WebAssembly содержит ресурсы глобализации, необходимые для отображения значений, таких как даты и денежные единицы, на языке пользователя и с его региональными параметрами. Если приложению не требуется локализация, можно [настроить поддержку инвариантных языка и региональных параметров](xref:blazor/globalization-localization), основанных на языке и региональных параметрах `en-US`:

  ```xml
  <PropertyGroup>
    <InvariantGlobalization>true</InvariantGlobalization>
  </PropertyGroup>
  ```

::: moniker-end

::: moniker range="< aspnetcore-5.0"

* Для правильной работы таких интерфейсов API, как <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, включаются сведения о параметрах сортировки. Если вы уверены, что приложению не нужны сведения о параметрах сортировки, эту функцию можно отключить, присвоив свойству MSBuild `BlazorWebAssemblyPreserveCollationData` в файле проекта приложения значение `false`:

  ```xml
  <PropertyGroup>
    <BlazorWebAssemblyPreserveCollationData>false</BlazorWebAssemblyPreserveCollationData>
  </PropertyGroup>
  ```

::: moniker-end
