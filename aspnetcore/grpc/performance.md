---
title: Лучшие методики повышения производительности gRPC
author: jamesnk
description: Ознакомьтесь с рекомендациями по созданию высокопроизводительных служб gRPC.
monikerRange: '>= aspnetcore-3.0'
ms.author: jamesnk
ms.date: 08/23/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: grpc/performance
ms.openlocfilehash: 622c6ba042c5832f99bba379fadd9aba7d7163f2
ms.sourcegitcommit: 3593c4efa707edeaaceffbfa544f99f41fc62535
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/04/2021
ms.locfileid: "93060408"
---
# <a name="performance-best-practices-with-grpc"></a>Лучшие методики повышения производительности gRPC

Автор: [Джеймс Ньютон-Кинг (James Newton-King)](https://twitter.com/jamesnk)

Система gRPC предназначена для создания высокопроизводительных служб. В этом документе описывается, как обеспечить максимальную производительность gRPC.

## <a name="reuse-grpc-channels"></a>Повторное использование каналов gRPC

При выполнении вызовов gRPC канал gRPC следует использовать повторно. Повторное использование канала позволяет мультиплексировать вызовы через существующее соединение HTTP/2.

Если для каждого вызова gRPC создается новый канал, то время, необходимое для его выполнения, может значительно возрасти. При каждом вызове потребуется несколько круговых путей по сети между клиентом и сервером для создания нового соединения HTTP/2:

1. открытие сокета;
2. установка TCP-соединения;
3. согласование TLS;
4. инициация соединения HTTP/2;
5. выполнение вызова gRPC.

Каналы можно безопасно использовать для нескольких вызовов gRPC.

* Клиенты gRPC создаются с помощью каналов. Клиенты gRPC являются облегченными объектами и не нуждаются в кэшировании или повторном использовании.
* Из одного канала можно создать несколько клиентов gRPC, включая различные типы клиентов.
* Канал и клиенты, созданные из канала, могут безопасно использоваться несколькими потоками.
* Клиенты, созданные из канала, могут выполнять несколько одновременных вызовов.

Фабрика клиента gRPC предлагает централизованный способ настройки каналов. Она автоматически повторно использует базовые каналы. Для получения дополнительной информации см. <xref:grpc/clientfactory>.

## <a name="connection-concurrency"></a>Параллелизм соединений

Обычно существует ограничение на [количество параллельных потоков (активных HTTP-запросов)](https://httpwg.github.io/specs/rfc7540.html#rfc.section.5.1.2) для одного соединения по HTTP/2. По умолчанию на большинстве серверов оно составляет 100 параллельных потоков.

Канал gRPC использует одно соединение HTTP/2, параллельные вызовы по которому мультиплексируются. Когда число активных вызовов достигает предельного числа потоков для соединения, дополнительные вызовы помещаются в очередь в клиенте. Вызовы в очереди ожидают завершения активных вызовов. Приложения с высокой нагрузкой или длительными потоковыми вызовами gRPC могут испытывать проблемы с производительностью, вызванные помещением вызовов в очередь из-за этого ограничения.

::: moniker range=">= aspnetcore-5.0"

В .NET 5 появилось свойство `SocketsHttpHandler.EnableMultipleHttp2Connections`. Если ему присвоено значение `true`, то при достижении предельного числа параллельных потоков канал создает дополнительные соединения HTTP/2. При создании `GrpcChannel` его внутренний обработчик `SocketsHttpHandler` автоматически настраивается так, чтобы создавались дополнительные соединения HTTP/2. Если приложение настраивает собственный обработчик, рекомендуется присвоить свойству `EnableMultipleHttp2Connections` значение `true`.

```csharp
var channel = GrpcChannel.ForAddress("https://localhost", new GrpcChannelOptions
{
    HttpHandler = new SocketsHttpHandler
    {
        EnableMultipleHttp2Connections = true,

        // ...configure other handler settings
    }
});
```

::: moniker-end

Для приложений .NET Core 3.1 существует несколько обходных путей.

* Создайте отдельные каналы gRPC для частей приложения с высокой нагрузкой. Например, служба gRPC `Logger` может испытывать высокую нагрузку. Используйте отдельный канал для создания `LoggerClient` в приложении.
* Используйте пул каналов gRPC, например создайте их список. `Random` используется для выбора канала из списка каждый раз, когда требуется канал gRPC. Использование `Random` позволяет случайным образом распределять вызовы между несколькими соединениями.

> [!IMPORTANT]
> Еще один способ решить эту проблему — увеличить максимальное число параллельных потоков на сервере. В Kestrel оно настраивается с помощью <xref:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.MaxStreamsPerConnection>.
>
> Увеличивать максимальное число параллельных потоков не рекомендуется. Слишком большое число потоков в одном соединении HTTP/2 вызывает новые проблемы с производительностью.
>
> * Возникает состязание между потоками, пытающимися выполнить запись через соединение.
> * Потеря пакетов, передаваемых через соединение, приводит к блокировке всех вызовов на уровне TCP.

## <a name="load-balancing"></a>Балансировка нагрузки

Некоторые подсистемы балансировки нагрузки не могут эффективно работать с gRPC. Подсистемы балансировки нагрузки L4 (транспортировка) действуют на уровне соединения путем распределения TCP-подключений между конечными точками. Такой способ хорошо подходит для вызовов API балансировки нагрузки, выполняемых с помощью HTTP/1.1. Одновременные вызовы, выполняемые с помощью HTTP/1.1, отправляются по разным соединениям, что позволяет распределять нагрузку вызовов между конечными точками.

Так как подсистемы балансировки нагрузки L4 работают на уровне соединения, они плохо работают с gRPC. gRPC использует HTTP/2, что приводит к мультиплексированию нескольких вызовов в одном TCP-подключении. Все вызовы gRPC через это подключение поступают в одну конечную точку.

Существует два варианта эффективного распределения нагрузки gRPC.

* Балансировка нагрузки на стороне клиента
* Балансировка нагрузки на прокси-сервере L7 (приложения)

> [!NOTE]
> Между конечными точками может распределяться только нагрузка вызовов gRPC. После установки вызова gRPC потоковой передачи все сообщения, отправленные в этом потоке, поступают в одну конечную точку.

### <a name="client-side-load-balancing"></a>Балансировка нагрузки на стороне клиента

При использовании балансировки нагрузки на стороне клиента клиент осведомлен о конечных точках. При каждом вызове gRPC клиент выбирает другую конечную точку для отправки вызова. Балансировка нагрузки на стороне клиента прекрасно подходит в случаях, когда задержка играет важную роль. Между клиентом и службой нет прокси-сервера, поэтому вызов отправляется в службу напрямую. Недостаток балансировки нагрузки на стороне клиента заключается в том, что каждый клиент должен отслеживать доступные конечные точки, которые ему нужно использовать.

Балансировка нагрузки клиента с резервированием — это метод, где состояние балансировки нагрузки хранится в центральном расположении. Клиенты периодически запрашивают в центральном расположении сведения, которые используются при принятии решений для балансировки нагрузки.

`Grpc.Net.Client` пока не поддерживает балансировку нагрузки на стороне клиента. Если в .NET требуется балансировка нагрузки на стороне клиента, рекомендуется использовать [Grpc.Core](https://www.nuget.org/packages/Grpc.Core).

### <a name="proxy-load-balancing"></a>Балансировка нагрузки на прокси-сервере

Прокси-сервер L7 (приложения) работает на более высоком уровне, чем прокси-сервер L4 (транспортировка). Прокси-серверы L7 поддерживают HTTP/2 и могут распределять вызовы gRPC, мультиплексированные на прокси-сервер через одно подключение HTTP/2, между несколькими конечными точками. Использование прокси-сервера проще, чем балансировка нагрузки на стороне клиента, но может увеличить задержку при вызовах gRPC.

Доступно множество прокси-серверов L7. Вот некоторые варианты:

* [Envoy](https://www.envoyproxy.io/) — популярный прокси-сервер с открытым кодом;
* [Linkerd](https://linkerd.io/) — сетка Service Kubernetes.
* [YARP: обратный прокси-сервер](https://microsoft.github.io/reverse-proxy/) — предварительная версия прокси-сервера с открытым кодом, написанным на .NET.

::: moniker range=">= aspnetcore-5.0"

## <a name="inter-process-communication"></a>Межпроцессное взаимодействие

Вызовы gRPC между клиентом и службой обычно отправляются через сокеты TCP. Протокол TCP отлично подходит для обмена данными по сети, однако [межпроцессное взаимодействие (IPC)](https://wikipedia.org/wiki/Inter-process_communication) более эффективно, если клиент и служба находятся на одном компьютере.

Для вызовов gRPC между процессами на одном компьютере рассмотрите возможность использования такого транспорта, как сокеты доменов UNIX или именованные каналы. Для получения дополнительной информации см. <xref:grpc/interprocess>.

## <a name="keep-alive-pings"></a>Пакеты проверки активности

Пакеты проверки активности могут использоваться для поддержания соединений HTTP/2 в активном состоянии в периоды бездействия. Готовность соединения HTTP/2 на момент возобновления работы приложения позволяет быстро выполнять первые вызовы gRPC без задержки, вызванной повторным установлением соединения.

Пакеты проверки активности настраиваются в <xref:System.Net.Http.SocketsHttpHandler>.

```csharp
var handler = new SocketsHttpHandler
{
    PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan,
    KeepAlivePingDelay = TimeSpan.FromSeconds(60),
    KeepAlivePingTimeout = TimeSpan.FromSeconds(30),
    EnableMultipleHttp2Connections = true
};

var channel = GrpcChannel.ForAddress("https://localhost:5001", new GrpcChannelOptions
{
    HttpHandler = handler
});
```

Приведенный выше код настраивает канал, который отправляет пакет проверки активности на сервер каждые 60 секунд в периоды бездействия. Проверка активности гарантирует, что сервер и все используемые прокси-серверы не закроют соединение из-за бездействия.

::: moniker-end

## <a name="streaming"></a>Потоковая передача

В высокопроизводительных сценариях вместо отдельных вызовов gRPC может использоваться двунаправленная потоковая передача gRPC. После запуска двунаправленного потока потоковая передача сообщений в обе стороны происходит быстрее, чем отправка сообщений для нескольких отдельных вызовов gRPC. Потоковые сообщения отправляются в виде данных существующего запроса HTTP/2, благодаря чему устраняются издержки на создание запроса HTTP/2 для каждого отдельного вызова.

Пример службы:

```csharp
public override async Task SayHello(IAsyncStreamReader<HelloRequest> requestStream,
    IServerStreamWriter<HelloReply> responseStream, ServerCallContext context)
{
    await foreach (var request in requestStream.ReadAllAsync())
    {
        var helloReply = new HelloReply { Message = "Hello " + request.Name };

        await responseStream.WriteAsync(helloReply);
    }
}
```

Пример клиента:

```csharp
var client = new Greet.GreeterClient(channel);
using var call = client.SayHello();

Console.WriteLine("Type a name then press enter.");
while (true)
{
    var text = Console.ReadLine();

    // Send and receive messages over the stream
    await call.RequestStream.WriteAsync(new HelloRequest { Name = text });
    await call.ResponseStream.MoveNext();

    Console.WriteLine($"Greeting: {call.ResponseStream.Current.Message}");
}
```

Замена отдельных вызовов на двунаправленную потоковую передачу для повышения производительности — сложный в реализации метод, который не подходит во многих ситуациях.

Использовать потоковые вызовы рекомендуется в указанных ниже случаях.

1. Требуется высокая пропускная способность или низкая задержка.
2. gRPC и HTTP/2 были определены как узкие места производительности.
3. Рабочая роль клиента регулярно отправляет или получает сообщения с помощью службы gRPC.

Обратите внимание на дополнительные сложности и ограничения, связанные с использованием потоковых вызовов вместо отдельных.

1. Поток может быть прерван службой или ошибкой соединения. Для перезапуска потока при возникновении ошибки требуется логика.
2. `RequestStream.WriteAsync` небезопасно использовать в режиме многопоточности. В поток за раз можно записать только одно сообщение. Для отправки сообщений из нескольких потоков требуется очередь производителя или потребителя, например <xref:System.Threading.Channels.Channel%601>, для маршалирования сообщений.
3. Метод потоковой передачи gRPC ограничен получением и отправкой сообщений одного типа. Например, `rpc StreamingCall(stream RequestMessage) returns (stream ResponseMessage)` получает `RequestMessage` и отправляет `ResponseMessage`. Поддержка неизвестных или условных сообщений в protobuf благодаря `Any` и `oneof` позволяет обойти это ограничение.
