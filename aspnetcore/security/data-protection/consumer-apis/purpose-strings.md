---
title: Строки назначения в ASP.NET Core
author: rick-anderson
description: Узнайте, как строки назначения используются в ASP.NET Core интерфейсах API защиты данных.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/consumer-apis/purpose-strings
ms.openlocfilehash: 9a55131714b23909da5d00b73607078b295a1c4d
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2020
ms.locfileid: "93060811"
---
# <a name="purpose-strings-in-aspnet-core"></a>Строки назначения в ASP.NET Core

<a name="data-protection-consumer-apis-purposes"></a>

Компоненты, которые используют, `IDataProtectionProvider` должны передавать в метод параметр с уникальными *целями* `CreateProtector` . *Параметр* цели является неотъемлемой частью безопасности системы защиты данных, так как он обеспечивает изоляцию между криптографическими клиентами, даже если корневые криптографические ключи одинаковы.

Когда потребитель указывает назначение, строка назначения используется вместе с корневыми криптографическими ключами для получения криптографических подразделов, уникальных для этого потребителя. Это изолирует потребителя от всех других криптографических потребителей в приложении: никакие другие компоненты не могут считывать свои полезные данные и не могут считывать полезные данные какого-либо другого компонента. Эта изоляция также позволяет визуализировать все категории атак на компонент.

![Пример схемы назначения](purpose-strings/_static/purposes.png)

На приведенной выше схеме `IDataProtector` экземпляры A и B **не могут** считывать полезные данные друг друга, а только их собственные.

Строка назначения не обязательно должна быть секретной. Он должен быть уникальным в том смысле, что ни один из других некорректно настроенных компонентов никогда не предоставит ту же строку назначения.

>[!TIP]
> Использование пространства имен и имени типа компонента, использующего API-интерфейсы защиты данных, является хорошим правилом для Thumb, так как на практике эти сведения никогда не будут конфликтовать.
>
>Компонент, разработанный Contoso, который отвечает за токены носителя минтинг, может использовать contoso. Security. Беарертокен в качестве строки назначения. Или еще лучше — в качестве строки назначения может использоваться contoso. Security. Беарертокен. v1. Добавление номера версии позволяет будущей версии использовать contoso. Security. Беарертокен. v2 в качестве цели, и разные версии будут полностью изолированы друг от друга, как только найдутся полезные данные.

Так как параметр целей `CreateProtector` является массивом строк, приведенный выше способ мог бы быть указан как `[ "Contoso.Security.BearerToken", "v1" ]` . Это позволяет устанавливать иерархию целей и откроет возможность использования многоядерных сценариев с системой защиты данных.

<a name="data-protection-contoso-purpose"></a>

>[!WARNING]
> Компоненты не должны разрешать ввод ненадежных пользователей в качестве единственного источника входных данных для цепочки целей.
>
>Например, рассмотрим компонент contoso. Messaging. Секуремессаже, который отвечает за хранение безопасных сообщений. Если компонент защищенного обмена сообщениями был вызван `CreateProtector([ username ])` , злоумышленник может создать учетную запись с именем "contoso. Security. беарертокен" в попытке получить вызов компонента `CreateProtector([ "Contoso.Security.BearerToken" ])` , что непреднамеренно приводит к тому, что защищенная система обмена сообщениями Mint полезные данные, которые могут восприниматься как маркеры проверки подлинности.
>
>Более лучшей цепочкой для компонента обмена сообщениями будет `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])` , что обеспечивает надлежащую изоляцию.

Изоляция, предоставляемая и поведением `IDataProtectionProvider` , и, заключается в `IDataProtector` следующем.

* Для данного `IDataProtectionProvider` объекта `CreateProtector` метод создает `IDataProtector` объект, который однозначно привязан к `IDataProtectionProvider` объекту, создавшему этот объект, и параметру, который был передан в метод.

* Параметр цели не может иметь значение null. (Если в качестве массива указано значение, это означает, что массив не должен иметь нулевую длину, а все элементы массива должны иметь значение, отличное от NULL.) Назначение пустой строки технически разрешено, но не рекомендуется.

* Аргументы двух целей эквивалентны, только если они содержат одни и те же строки (с использованием сравнения порядков) в том же порядке. Аргумент с одним целям эквивалентен одному одноэлементному массиву целей.

* Два `IDataProtector` объекта эквивалентны, только если они создаются из эквивалентных `IDataProtectionProvider` объектов с помощью параметров эквивалентных целей.

* Для данного `IDataProtector` объекта вызов метода возвратит `Unprotect(protectedData)` исходный результат, `unprotectedData` только если `protectedData := Protect(unprotectedData)` для эквивалентного `IDataProtector` объекта.

> [!NOTE]
> Мы не будем учитывать случай, когда некоторый компонент намеренно выбрал строку назначения, которая может конфликтовать с другим компонентом. Такой компонент, по сути, считается вредоносным, и эта система не предназначена для предоставления гарантий безопасности в случае, если вредоносный код уже выполняется в рабочем процессе.
